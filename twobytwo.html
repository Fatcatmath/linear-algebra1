<!DOCTYPE html> <!-- -*- html -*- -->
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
  <title>2x2矩阵变换演示（优化版）</title> <!-- 1. 修改标题 -->
  <link rel="shortcut icon" href="img/gatech.gif"/>
  <link rel="stylesheet" href="css/demo.css?vers=2759ff">
  <style>
    #help-text {
      text-align: center;
      color: #666;
      margin: 10px 0;
      font-size: 14px;
    }
    #det-text {
      text-align: center;
      color: #3366cc;
      font-weight: bold;
      margin: 5px 0;
    }
    .caption {
      margin: 20px auto;
      max-width: 800px;
    }
    /* 3. 优化公式显示样式 */
    #eqn-here {
      font-size: 18px;
      display: inline-block;
      padding: 10px 20px;
      background: #f5fafe;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <script src="js/demo.js?vers=77646a"></script>
  <script type="text/javascript">
    "use strict";
    DomReady.ready(function() {
      var color1, color2, ortho, ref,
        bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

      ortho = 10000;
      color1 = new Color("#2ecc71"); // 1. 调整输入向量颜色（清新绿）
      color2 = new Color("#e74c3c"); // 调整输出向量颜色（醒目红）

      window.demo = new Demo2D({
        preload: {
          // 2. 更换背景图（支持本地图片或网络图片）
          image: 'img/' + ((ref = urlParams.pic) != null ? ref : "lena.jpg") 
          // 若要使用网络图片：image: "https://picsum.photos/800/800"
        },
        ortho: ortho,
        camera: {
          position: [1.1, 0, ortho],
          lookAt: [1.1, 0, 0]
        },
        vertical: 2.2
      }, function() {
        var Params, axisOpts, clipCube, computeIn, computeMatrix, computeOut, drag2, 
            eqnElt, detElt, folder, gridOpts, gui, hiliteOpts, i, inVec, inverse, j, 
            labelOpts, matrix, numTransforms, outVec, params, paramses, ref1, 
            updateCaption, updateDeterminant, vectorOpts, view1, view2, zeroOpts;
        
        window.mathbox = this.mathbox;
        matrix = this.urlParams.get('mat', 'float[]', [1, 0, 0, 1]);
        numTransforms = this.urlParams.get('num', 'int', 4); // 4. 增加变换步骤到4个
        inverse = null;

        // 5. 新增：显示矩阵行列式
        updateDeterminant = function() {
          var det = matrix[0] * matrix[3] - matrix[1] * matrix[2];
          det = det.toFixed(3); // 保留3位小数
          detElt.innerHTML = `矩阵行列式：${det}（行列式≠0时可逆）`;
          return det;
        };

        updateCaption = (function(_this) {
          return function() {
            var str;
            str = _this.texMatrix([[matrix[0].toFixed(2), matrix[2].toFixed(2)], 
                                   [matrix[1].toFixed(2), matrix[3].toFixed(2)]]); // 矩阵元素保留2位小数
            str += _this.texVector(inVec.slice(0,2), {color: color1});
            str += '=' + _this.texVector(outVec.slice(0,2), {color: color2});
            return katex.render(str, eqnElt);
          };
        })(this);

        computeMatrix = (function(_this) {
          return function(first) {
            var a, b, c, d, det, j, len, mat, mult, params;
            if (!first) {
              mat = [1, 0, 0, 1];
              for (j = 0, len = paramses.length; j < len; j++) {
                params = paramses[j];
                mult = params.matrix;
                a = mult[0] * mat[0] + mult[1] * mat[2];
                b = mult[0] * mat[1] + mult[1] * mat[3];
                c = mult[2] * mat[0] + mult[3] * mat[2];
                d = mult[2] * mat[1] + mult[3] * mat[3];
                mat = [a, b, c, d];
              }
              matrix[0] = mat[0];
              matrix[1] = mat[1];
              matrix[2] = mat[2];
              matrix[3] = mat[3];
            }
            det = updateDeterminant(); // 计算并显示行列式
            if (det * det < 0.00001) {
              inverse = null;
              drag2.enabled = false;
              detElt.style.color = "#e74c3c"; // 行列式为0时标红
            } else {
              inverse = [matrix[3] / det, -matrix[1] / det, -matrix[2] / det, matrix[0] / det];
              drag2.enabled = true;
              detElt.style.color = "#3366cc"; // 行列式非0时标蓝
            }
            computeOut();
            return updateCaption();
          };
        })(this);

        Params = (function() {
          function Params() {
            this.doRotate = bind(this.doRotate, this);
            this.doYShear = bind(this.doYShear, this);
            this.doXShear = bind(this.doXShear, this);
            this.doScale = bind(this.doScale, this);
            this.xscale = 1.0;
            this.yscale = 1.0;
            this.xshear = 0.0;
            this.yshear = 0.0;
            this.rotate = 0.0;
            this.matrix = [1, 0, 0, 1];
          }

          Params.prototype.doScale = function() {
            this.rotate = this.xshear = this.yshear = 0.0;
            this.matrix = [this.xscale, 0, 0, this.yscale];
            return computeMatrix();
          };

          Params.prototype.doXShear = function() {
            this.xscale = this.yscale = 1.0;
            this.rotate = this.yshear = 0.0;
            this.matrix = [1, this.xshear, 0, 1];
            return computeMatrix();
          };

          Params.prototype.doYShear = function() {
            this.xscale = this.yscale = 1.0;
            this.rotate = this.xshear = 0.0;
            this.matrix = [1, 0, this.yshear, 1];
            return computeMatrix();
          };

          Params.prototype.doRotate = function() {
            var c, s;
            this.xscale = this.yscale = 1.0;
            this.xshear = this.yshear = 0.0;
            c = Math.cos(this.rotate);
            s = Math.sin(this.rotate);
            this.matrix = [c, -s, s, c];
            return computeMatrix();
          };

          return Params;
        })();

        paramses = [];
        gui = new dat.GUI();
        gui.closed = false; // 6. GUI面板默认展开（原默认收起）
        gui.width = 300; // 调整GUI宽度

        // 7. 新增：重置所有变换按钮
        gui.add({reset: function() {
          paramses.forEach(function(params) {
            params.xscale = 1.0;
            params.yscale = 1.0;
            params.xshear = 0.0;
            params.yshear = 0.0;
            params.rotate = 0.0;
            params.matrix = [1, 0, 0, 1];
          });
          gui.updateDisplay(); // 更新GUI显示
          computeMatrix();
        }}, 'reset').name('重置所有变换');

        for (i = j = 0, ref1 = numTransforms; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
          folder = gui.addFolder("变换 " + (i + 1)); // 中文标签更友好
          params = new Params();
          if (i === 0) folder.open(); // 第一个变换默认展开
          
          // 8. 调整参数范围（缩放从-2~2扩大到-3~3，剪切范围优化）
          folder.add(params, 'x轴放缩', -3, 3).step(0.05).onChange(params.doScale).listen();
          folder.add(params, 'y轴放缩', -3, 3).step(0.05).onChange(params.doScale).listen();
          folder.add(params, '旋转', -Math.PI, Math.PI).step(0.05 * Math.PI).onChange(params.doRotate).listen();
          folder.add(params, 'x轴剪切', -3, 3).step(0.05).onChange(params.doXShear).listen();
          folder.add(params, 'y轴剪切', -3, 3).step(0.05).onChange(params.doYShear).listen();
          
          paramses.push(params);
        }

        // 调整网格和坐标轴样式
        gridOpts = {
          color: 'white',
          opacity: 0.3, // 提高网格透明度
          width: 1,
          zOrder: 1,
          zIndex: 1
        };
        axisOpts = {
          color: '#3498db', // 坐标轴改为蓝色
          opacity: 0.8, // 提高坐标轴透明度
          zIndex: 1,
          zOrder: 1,
          size: 3
        };

        // 左侧原始视图
        view1 = this.view({
          name: 'view1',
          gridOpts: gridOpts,
          axisOpts: axisOpts,
          axisLabels: true // 显示坐标轴标签（x/y）
        });
        view1.image({
          image: this.image
        }).matrix({
          width: 2,
          height: 2,
          channels: 2,
          data: [[[-10, -10], [10, -10]], [[-10, 10], [10, 10]]]
        }).surface({
          color: 'white',
          points: '<',
          map: '<<',
          fill: true,
          zOrder: 0
        });

        // 右侧变换后视图
        view2 = this.view({
          name: 'view2',
          viewOpts: {
            position: [2.2, 0, 0]
          },
          gridOpts: gridOpts,
          axisOpts: axisOpts,
          axisLabels: true // 显示坐标轴标签
        });

        clipCube = this.clipCube(view2, {
          draw: false,
          hilite: false,
          range: 10.0,
          pass: 'view'
        });
        clipCube.clipped.transform({}, {
          matrix: function() {
            return [matrix[0], matrix[1], 0, 0, 
                    matrix[2], matrix[3], 0, 0, 
                    0, 0, 1, 0, 0, 0, 0, 1];
          }
        }).image({
          image: this.image
        }).matrix({
          width: 2,
          height: 2,
          channels: 2,
          data: [[[-10, -10], [10, -10]], [[-10, 10], [10, 10]]]
        }).surface({
          color: 'white',
          points: '<',
          map: '<<',
          fill: true,
          zOrder: 0
        });

        // 向量计算逻辑
        computeOut = function() {
          outVec[0] = matrix[0] * inVec[0] + matrix[1] * inVec[1];
          outVec[1] = matrix[2] * inVec[0] + matrix[3] * inVec[1];
        };
        computeIn = function() {
          if (inverse != null) {
            inVec[0] = inverse[0] * outVec[0] + inverse[1] * outVec[1];
            inVec[1] = inverse[2] * outVec[0] + inverse[3] * outVec[1];
          }
        };

        // 向量样式优化
        vectorOpts = {
          size: 5, // 增大向量箭头
          width: 4, // 加粗向量线
          zIndex: 2
        };
        zeroOpts = {
          zIndex: 2,
          size: 18 // 增大原点标记
        };
        labelOpts = {
          offset: [0, 25],
          size: 16, // 增大标签字体
          zIndex: 3,
          outline: 0,
          background: "rgba(255,255,255,0.8)" // 半透明背景
        };
        hiliteOpts = {
          zTest: true,
          zWrite: true,
          zOrder: 2,
          opacity: 0.7 // 提高拖拽高亮透明度
        };

        // 输入向量（初始位置调整为[3,2]）
        inVec = [3, 2, 0];
        this.labeledVectors(view1, {
          name: 'labeled1',
          vectors: [inVec],
          colors: [color1.brighten(.2)], // 提亮颜色
          labels: ['输入向量 x'], // 更清晰的标签
          live: true,
          zeroPoints: true,
          zeroThreshold: 0.3,
          vectorOpts: vectorOpts,
          labelOpts: labelOpts,
          zeroOpts: zeroOpts
        });
        this.draggable(view1, {
          name: 'drag1',
          points: [inVec],
          onDrag: computeOut,
          postDrag: updateCaption,
          hiliteOpts: hiliteOpts
        });

        // 输出向量
        outVec = [3, 2, 0];
        this.labeledVectors(view2, {
          name: 'labeled2',
          vectors: [outVec],
          colors: [color2.brighten(.2)],
          labels: ['输出向量 b'],
          live: true,
          zeroPoints: true,
          zeroThreshold: 0.3,
          vectorOpts: vectorOpts,
          labelOpts: labelOpts,
          zeroOpts: zeroOpts
        });
        drag2 = this.draggable(view2, {
          name: 'drag2',
          points: [outVec],
          onDrag: computeIn,
          postDrag: updateCaption,
          hiliteOpts: hiliteOpts
        });

        // 页面标题和说明
        this.caption(`
          <h2 style="text-align:center; color:#2c3e50;">2x2矩阵变换交互式演示</h2>
          <p id="det-text"></p> <!-- 行列式显示区域 -->
          <p style="text-align:center;"><span id="eqn-here"></span></p>
          <p id="help-text">✓ 拖拽左侧"输入向量x"查看变换结果 | ✓ 行列式≠0时可拖拽右侧"输出向量b"反推输入</p>
        `);
        eqnElt = document.getElementById('eqn-here');
        detElt = document.getElementById('det-text'); // 绑定行列式元素
        return computeMatrix(true);
      });
    });
  </script>
</body>
</html>
