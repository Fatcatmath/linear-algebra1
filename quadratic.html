<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äºŒæ¬¡å‹ä¸äºŒæ¬¡æ›²é¢å¯è§†åŒ–</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            max-width: 450px;
            backdrop-filter: blur(10px);
        }
        .info-panel h2 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 1.4em;
        }
        .formula-container {
            background: rgba(245, 245, 245, 0.8);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #3498db;
        }
        .status-item {
            margin: 8px 0;
            padding: 8px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 6px;
            font-size: 0.95em;
        }
        .positive { color: #27ae60; font-weight: 600; }
        .negative { color: #e74c3c; font-weight: 600; }
        .mixed { color: #f39c12; font-weight: 600; }
        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            max-height: 80vh;
            overflow-y: auto;
        }
        .surface-type {
            background: rgba(155, 89, 182, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #9b59b6;
        }
        .axis-legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9em;
        }
        .axis-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .axis-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="info-panel">
        <h2>ğŸ¯ äºŒæ¬¡å‹ä¸äºŒæ¬¡æ›²é¢å¯è§†åŒ–</h2>
        
        <div class="formula-container" id="formula">
            æ­£åœ¨åŠ è½½å…¬å¼...
        </div>
        
        <div class="surface-type">
            <strong>æ›²é¢ç±»å‹:</strong> <span id="surface-type">æ¤­çƒé¢</span>
        </div>
        
        <div class="status-item">
            <strong>çŸ©é˜µç‰¹å¾:</strong> <span id="matrix-status" class="positive">æ­£å®š</span>
        </div>
        
        <div class="status-item">
            <strong>ç‰¹å¾å€¼ (Î»â‚, Î»â‚‚, Î»â‚ƒ):</strong> <span id="eigenvalues">è®¡ç®—ä¸­...</span>
        </div>
        
        <div class="status-item">
            <strong>ä¸»è½´é•¿åº¦:</strong> <span id="axis-lengths">è®¡ç®—ä¸­...</span>
        </div>
        
        <div style="margin-top: 15px; font-size: 0.9em; color: #7f8c8d;">
            ğŸ’¡ è°ƒæ•´å‚æ•°è§‚å¯Ÿå„ç§äºŒæ¬¡æ›²é¢çš„å˜åŒ–<br>
            ğŸ® é¼ æ ‡æ‹–æ‹½æ—‹è½¬ï¼Œæ»šè½®ç¼©æ”¾
        </div>
    </div>

    <div class="control-panel" id="control-panel">
        <!-- GUIæ§ä»¶å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
    </div>

    <div class="axis-legend">
        <div class="axis-item">
            <div class="axis-color" style="background: #ff4444;"></div>
            <span>ä¸»è½´ 1 (å¯¹åº” Î»â‚)</span>
        </div>
        <div class="axis-item">
            <div class="axis-color" style="background: #44ff44;"></div>
            <span>ä¸»è½´ 2 (å¯¹åº” Î»â‚‚)</span>
        </div>
        <div class="axis-item">
            <div class="axis-color" style="background: #4444ff;"></div>
            <span>ä¸»è½´ 3 (å¯¹åº” Î»â‚ƒ)</span>
        </div>
    </div>

    <script>
        // åˆå§‹åŒ–Three.jsåœºæ™¯
        let scene, camera, renderer, surface, axesHelper;
        let principalAxes = [];
        let quadraticMatrix = [[2.0, 0.5, 0.3], [0.5, 1.0, -0.2], [0.3, -0.2, 0.8]];
        
        // ä¸»è½´é¢œè‰²
        const axisColors = [0xff4444, 0x44ff44, 0x4444ff];
        
        // æ›²é¢ç±»å‹å®šä¹‰
        const SurfaceTypes = {
            ELLIPSOID: 'ellipsoid',
            HYPERBOLOID_ONE_SHEET: 'hyperboloid_one_sheet',
            HYPERBOLOID_TWO_SHEETS: 'hyperboloid_two_sheets',
            CONE: 'cone',
            CYLINDER: 'cylinder',
            PARABOLOID: 'paraboloid'
        };
        
        // åˆå§‹åŒ–å‡½æ•°
        function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(6, 6, 6);
            camera.lookAt(0, 0, 0);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // æ·»åŠ å…‰æº
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            // åˆ›å»ºåæ ‡è½´
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            
            // åˆ›å»ºç½‘æ ¼
            const gridHelper = new THREE.GridHelper(10, 10, 0x888888, 0x888888);
            gridHelper.rotation.x = Math.PI / 2;
            scene.add(gridHelper);
            
            // åˆ›å»ºåˆå§‹æ›²é¢
            createSurface();
            
            // åˆ›å»ºä¸»è½´
            createPrincipalAxes();
            
            // åˆå§‹åŒ–æ§åˆ¶å™¨
            initControls();
            
            // åˆå§‹æ¸²æŸ“
            updateInfo();
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();
            
            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize);
            
            // æ·»åŠ é¼ æ ‡æ§åˆ¶
            initMouseControls();
        }
        
        // åˆå§‹åŒ–é¼ æ ‡æ§åˆ¶
        function initMouseControls() {
            let isMouseDown = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!isMouseDown) return;
                
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                if (surface) {
                    surface.rotation.y += deltaX * 0.01;
                    surface.rotation.x += deltaY * 0.01;
                    
                    // ä¸»è½´ä¹Ÿè·Ÿéšæ—‹è½¬
                    principalAxes.forEach(axis => {
                        axis.rotation.y += deltaX * 0.01;
                        axis.rotation.x += deltaY * 0.01;
                    });
                }
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                camera.position.multiplyScalar(1 + e.deltaY * 0.001);
            });
        }
        
        // åˆ›å»ºæ›²é¢
        function createSurface() {
            if (surface) {
                scene.remove(surface);
            }
            
            const surfaceType = analyzeSurfaceType();
            const geometry = createSurfaceGeometry(surfaceType);
            const material = new THREE.MeshPhongMaterial({ 
                color: getSurfaceColor(surfaceType),
                transparent: true,
                opacity: 0.8,
                shininess: 100,
                side: THREE.DoubleSide
            });
            
            surface = new THREE.Mesh(geometry, material);
            
            // åº”ç”¨å˜æ¢
            applySurfaceTransformation(surfaceType);
            
            scene.add(surface);
        }
        
        // åˆ†ææ›²é¢ç±»å‹
        function analyzeSurfaceType() {
            const eigenResult = eigenDecomposition(quadraticMatrix);
            const eigenvalues = eigenResult.values;
            
            const positiveCount = eigenvalues.filter(lambda => lambda > 1e-6).length;
            const negativeCount = eigenvalues.filter(lambda => lambda < -1e-6).length;
            const zeroCount = eigenvalues.filter(lambda => Math.abs(lambda) <= 1e-6).length;
            
            if (positiveCount === 3) return SurfaceTypes.ELLIPSOID;
            if (negativeCount === 3) return SurfaceTypes.ELLIPSOID; // è´Ÿå®šä¹Ÿæ˜¯æ¤­çƒ
            if (positiveCount === 2 && negativeCount === 1) return SurfaceTypes.HYPERBOLOID_ONE_SHEET;
            if (positiveCount === 1 && negativeCount === 2) return SurfaceTypes.HYPERBOLOID_TWO_SHEETS;
            if (zeroCount > 0) {
                if (positiveCount === 2 && zeroCount === 1) return SurfaceTypes.CYLINDER;
                if (positiveCount === 1 && negativeCount === 1 && zeroCount === 1) return SurfaceTypes.CONE;
            }
            
            return SurfaceTypes.ELLIPSOID; // é»˜è®¤
        }
        
        // åˆ›å»ºæ›²é¢å‡ ä½•ä½“
        function createSurfaceGeometry(surfaceType) {
            const resolution = 64;
            
            switch(surfaceType) {
                case SurfaceTypes.ELLIPSOID:
                    return new THREE.SphereGeometry(1, resolution, resolution);
                    
                case SurfaceTypes.HYPERBOLOID_ONE_SHEET:
                    return createHyperboloidGeometry(1, resolution, false);
                    
                case SurfaceTypes.HYPERBOLOID_TWO_SHEETS:
                    return createHyperboloidGeometry(1, resolution, true);
                    
                case SurfaceTypes.CONE:
                    return new THREE.ConeGeometry(1, 2, resolution);
                    
                case SurfaceTypes.CYLINDER:
                    return new THREE.CylinderGeometry(1, 1, 2, resolution);
                    
                default:
                    return new THREE.SphereGeometry(1, resolution, resolution);
            }
        }
        
        // åˆ›å»ºåŒæ›²é¢å‡ ä½•ä½“
        function createHyperboloidGeometry(scale, resolution, twoSheets) {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            
            const uCount = resolution;
            const vCount = resolution;
            
            for (let i = 0; i <= uCount; i++) {
                const u = (i / uCount) * Math.PI * 2;
                for (let j = 0; j <= vCount; j++) {
                    const v = (j / vCount) * 4 - 2; // v from -2 to 2
                    
                    let x, y, z;
                    if (twoSheets) {
                        // åŒå¶åŒæ›²é¢
                        x = scale * Math.sinh(v) * Math.cos(u);
                        y = scale * Math.sinh(v) * Math.sin(u);
                        z = scale * Math.cosh(v);
                        if (v < 0) z = -z; // ç¬¬äºŒå¶
                    } else {
                        // å•å¶åŒæ›²é¢
                        x = scale * Math.cosh(v) * Math.cos(u);
                        y = scale * Math.cosh(v) * Math.sin(u);
                        z = scale * Math.sinh(v);
                    }
                    
                    vertices.push(x, y, z);
                }
            }
            
            // åˆ›å»ºç´¢å¼•
            for (let i = 0; i < uCount; i++) {
                for (let j = 0; j < vCount; j++) {
                    const a = i * (vCount + 1) + j;
                    const b = a + 1;
                    const c = a + (vCount + 1);
                    const d = c + 1;
                    
                    indices.push(a, b, d);
                    indices.push(a, d, c);
                }
            }
            
            geometry.setIndex(indices);
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.computeVertexNormals();
            
            return geometry;
        }
        
        // è·å–æ›²é¢é¢œè‰²
        function getSurfaceColor(surfaceType) {
            switch(surfaceType) {
                case SurfaceTypes.ELLIPSOID: return 0xff7700; // æ©™è‰²
                case SurfaceTypes.HYPERBOLOID_ONE_SHEET: return 0x44ff44; // ç»¿è‰²
                case SurfaceTypes.HYPERBOLOID_TWO_SHEETS: return 0xff4444; // çº¢è‰²
                case SurfaceTypes.CONE: return 0x8844ff; // ç´«è‰²
                case SurfaceTypes.CYLINDER: return 0x44bbff; // è“è‰²
                default: return 0xff7700;
            }
        }
        
        // åº”ç”¨æ›²é¢å˜æ¢
        function applySurfaceTransformation(surfaceType) {
            const eigenResult = eigenDecomposition(quadraticMatrix);
            const eigenvalues = eigenResult.values;
            const eigenvectors = eigenResult.vectors;
            
            // æ ¹æ®ç‰¹å¾å€¼è°ƒæ•´ç¼©æ”¾
            const scales = eigenvalues.map(lambda => {
                if (Math.abs(lambda) < 1e-6) return 2.0; // é›¶ç‰¹å¾å€¼å¯¹åº”æ— é™å»¶ä¼¸
                return 1 / Math.sqrt(Math.abs(lambda));
            });
            
            surface.scale.set(scales[0], scales[1], scales[2]);
            
            // åº”ç”¨æ—‹è½¬åˆ°ä¸»è½´æ–¹å‘
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.set(
                eigenvectors[0][0], eigenvectors[1][0], eigenvectors[2][0], 0,
                eigenvectors[0][1], eigenvectors[1][1], eigenvectors[2][1], 0,
                eigenvectors[0][2], eigenvectors[1][2], eigenvectors[2][2], 0,
                0, 0, 0, 1
            );
            
            surface.rotation.setFromRotationMatrix(rotationMatrix);
        }
        
        // åˆ›å»ºä¸»è½´ç®­å¤´
        function createPrincipalAxes() {
            // æ¸…é™¤ç°æœ‰ä¸»è½´
            principalAxes.forEach(axis => scene.remove(axis));
            principalAxes = [];
            
            const eigenResult = eigenDecomposition(quadraticMatrix);
            const eigenvalues = eigenResult.values;
            const eigenvectors = eigenResult.vectors;
            const surfaceType = analyzeSurfaceType();
            
            // å¯¹äºéæ¤­çƒæ›²é¢ï¼Œåªæ˜¾ç¤ºå®è½´
            for (let i = 0; i < 3; i++) {
                if (Math.abs(eigenvalues[i]) < 1e-6) continue; // è·³è¿‡é›¶ç‰¹å¾å€¼
                
                const axisLength = 2.5 / Math.sqrt(Math.abs(eigenvalues[i]));
                const direction = new THREE.Vector3(
                    eigenvectors[0][i],
                    eigenvectors[1][i],
                    eigenvectors[2][i]
                ).normalize();
                
                const arrowHelper = new THREE.ArrowHelper(
                    direction,
                    new THREE.Vector3(0, 0, 0),
                    axisLength,
                    axisColors[i],
                    0.15,
                    0.08
                );
                
                principalAxes.push(arrowHelper);
                scene.add(arrowHelper);
            }
        }
        
        // æ›´æ–°ä¸»è½´
        function updatePrincipalAxes() {
            createPrincipalAxes();
        }
        
        // åˆå§‹åŒ–æ§åˆ¶å™¨
        function initControls() {
            const guiParams = {
                Q11: quadraticMatrix[0][0],
                Q12: quadraticMatrix[0][1],
                Q13: quadraticMatrix[0][2],
                Q22: quadraticMatrix[1][1],
                Q23: quadraticMatrix[1][2],
                Q33: quadraticMatrix[2][2],
                showAxes: true,
                preset: 'ellipsoid',
                reset: function() {
                    this.Q11 = 2.0; this.Q12 = 0.5; this.Q13 = 0.3;
                    this.Q22 = 1.0; this.Q23 = -0.2;
                    this.Q33 = 0.8;
                    updateMatrix();
                    gui.updateDisplay();
                }
            };
            
            const gui = new dat.GUI({ 
                autoPlace: false,
                width: 320
            });
            
            document.getElementById('control-panel').appendChild(gui.domElement);
            
            const matrixFolder = gui.addFolder('çŸ©é˜µå‚æ•° Q');
            matrixFolder.add(guiParams, 'Q11', -3.0, 3.0).step(0.1).name('Qâ‚â‚').onChange(updateMatrix);
            matrixFolder.add(guiParams, 'Q12', -2.0, 2.0).step(0.1).name('Qâ‚â‚‚').onChange(updateMatrix);
            matrixFolder.add(guiParams, 'Q13', -2.0, 2.0).step(0.1).name('Qâ‚â‚ƒ').onChange(updateMatrix);
            matrixFolder.add(guiParams, 'Q22', -3.0, 3.0).step(0.1).name('Qâ‚‚â‚‚').onChange(updateMatrix);
            matrixFolder.add(guiParams, 'Q23', -2.0, 2.0).step(0.1).name('Qâ‚‚â‚ƒ').onChange(updateMatrix);
            matrixFolder.add(guiParams, 'Q33', -3.0, 3.0).step(0.1).name('Qâ‚ƒâ‚ƒ').onChange(updateMatrix);
            matrixFolder.open();
            
            const presetFolder = gui.addFolder('é¢„è®¾æ›²é¢');
            const presets = {
                'ellipsoid': [2.0, 0.5, 0.3, 1.0, -0.2, 0.8],
                'hyperboloid_one_sheet': [1.0, 0.0, 0.0, 1.0, 0.0, -0.5],
                'hyperboloid_two_sheets': [1.0, 0.0, 0.0, 1.0, 0.0, -2.0],
                'cone': [1.0, 0.0, 0.0, 1.0, 0.0, 0.0],
                'cylinder': [1.0, 0.0, 0.0, 1.0, 0.0, 0.0]
            };
            
            Object.keys(presets).forEach(key => {
                presetFolder.add({[key]: () => {
                    const preset = presets[key];
                    guiParams.Q11 = preset[0];
                    guiParams.Q12 = preset[1];
                    guiParams.Q13 = preset[2];
                    guiParams.Q22 = preset[3];
                    guiParams.Q23 = preset[4];
                    guiParams.Q33 = preset[5];
                    updateMatrix();
                    gui.updateDisplay();
                }}, key).name(key.replace('_', ' '));
            });
            presetFolder.open();
            
            const viewFolder = gui.addFolder('è§†å›¾æ§åˆ¶');
            viewFolder.add(guiParams, 'showAxes').name('æ˜¾ç¤ºä¸»è½´').onChange(function(value) {
                principalAxes.forEach(axis => {
                    axis.visible = value;
                });
            });
            viewFolder.add(guiParams, 'reset').name('é‡ç½®å‚æ•°');
            viewFolder.open();
            
            function updateMatrix() {
                quadraticMatrix[0][0] = guiParams.Q11;
                quadraticMatrix[0][1] = guiParams.Q12; quadraticMatrix[1][0] = guiParams.Q12;
                quadraticMatrix[0][2] = guiParams.Q13; quadraticMatrix[2][0] = guiParams.Q13;
                quadraticMatrix[1][1] = guiParams.Q22;
                quadraticMatrix[1][2] = guiParams.Q23; quadraticMatrix[2][1] = guiParams.Q23;
                quadraticMatrix[2][2] = guiParams.Q33;
                
                createSurface();
                updatePrincipalAxes();
                updateInfo();
            }
        }
        
        // æ›´æ–°ä¿¡æ¯æ˜¾ç¤º
        function updateInfo() {
            const eigenResult = eigenDecomposition(quadraticMatrix);
            const eigenvalues = eigenResult.values;
            const surfaceType = analyzeSurfaceType();
            
            // ç¡®å®šçŸ©é˜µç‰¹å¾
            const positiveCount = eigenvalues.filter(lambda => lambda > 1e-6).length;
            const negativeCount = eigenvalues.filter(lambda => lambda < -1e-6).length;
            let matrixStatus, statusClass;
            
            if (positiveCount === 3) {
                matrixStatus = 'æ­£å®š';
                statusClass = 'positive';
            } else if (negativeCount === 3) {
                matrixStatus = 'è´Ÿå®š';
                statusClass = 'negative';
            } else if (positiveCount > 0 && negativeCount > 0) {
                matrixStatus = 'ä¸å®š';
                statusClass = 'mixed';
            } else {
                matrixStatus = 'åŠå®š';
                statusClass = 'mixed';
            }
            
            // æ›²é¢ç±»å‹åç§°
            const surfaceNames = {
                [SurfaceTypes.ELLIPSOID]: 'æ¤­çƒé¢',
                [SurfaceTypes.HYPERBOLOID_ONE_SHEET]: 'å•å¶åŒæ›²é¢',
                [SurfaceTypes.HYPERBOLOID_TWO_SHEETS]: 'åŒå¶åŒæ›²é¢',
                [SurfaceTypes.CONE]: 'äºŒæ¬¡é”¥é¢',
                [SurfaceTypes.CYLINDER]: 'æ¤­åœ†æŸ±é¢'
            };
            
            // æ›´æ–°æ˜¾ç¤º
            document.getElementById('surface-type').textContent = surfaceNames[surfaceType] || 'äºŒæ¬¡æ›²é¢';
            document.getElementById('matrix-status').className = statusClass;
            document.getElementById('matrix-status').textContent = matrixStatus;
            document.getElementById('eigenvalues').textContent = 
                eigenvalues.map(lambda => lambda.toFixed(3)).join(', ');
            
            // ä¸»è½´é•¿åº¦ï¼ˆåªæ˜¾ç¤ºå®è½´ï¼‰
            const axisLengths = eigenvalues.map(lambda => 
                Math.abs(lambda) > 1e-6 ? (1 / Math.sqrt(Math.abs(lambda))).toFixed(3) : 'âˆ'
            );
            document.getElementById('axis-lengths').textContent = axisLengths.join(', ');
            
            // æ›´æ–°å…¬å¼
            renderFormula();
        }
        
        // æ¸²æŸ“å…¬å¼
        function renderFormula() {
            const Q = quadraticMatrix;
            const formulaTex = `
                \\begin{aligned}
                &\\text{äºŒæ¬¡å‹: } \\mathbf{x}^T Q \\mathbf{x} = 1 \\\\
                &Q = \\begin{pmatrix}
                ${Q[0][0].toFixed(2)} & ${Q[0][1].toFixed(2)} & ${Q[0][2].toFixed(2)} \\\\
                ${Q[1][0].toFixed(2)} & ${Q[1][1].toFixed(2)} & ${Q[1][2].toFixed(2)} \\\\
                ${Q[2][0].toFixed(2)} & ${Q[2][1].toFixed(2)} & ${Q[2][2].toFixed(2)}
                \\end{pmatrix}
                \\end{aligned}
            `;
            
            katex.render(formulaTex, document.getElementById('formula'), {
                displayMode: true,
                throwOnError: false
            });
        }
        
        // ç‰¹å¾å€¼åˆ†è§£å‡½æ•°ï¼ˆä¿æŒä¸å˜ï¼‰
        function eigenDecomposition(A) {
            let M = JSON.parse(JSON.stringify(A));
            
            for (let i = 0; i < 3; i++) {
                for (let j = i + 1; j < 3; j++) {
                    M[j][i] = M[i][j] = (M[i][j] + M[j][i]) / 2;
                }
            }
            
            let V = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
            const epsilon = 1e-9;
            const maxIterations = 100;
            
            for (let iter = 0; iter < maxIterations; iter++) {
                let maxVal = 0;
                let p, q;
                
                for (let i = 0; i < 3; i++) {
                    for (let j = i + 1; j < 3; j++) {
                        if (Math.abs(M[i][j]) > maxVal) {
                            maxVal = Math.abs(M[i][j]);
                            p = i;
                            q = j;
                        }
                    }
                }
                
                if (maxVal < epsilon) break;
                
                const theta = 0.5 * Math.atan2(2 * M[p][q], M[q][q] - M[p][p]);
                const c = Math.cos(theta);
                const s = Math.sin(theta);
                
                for (let i = 0; i < 3; i++) {
                    let a = M[i][p], b = M[i][q];
                    M[i][p] = a * c - b * s;
                    M[i][q] = a * s + b * c;
                    
                    a = M[p][i]; b = M[q][i];
                    M[p][i] = a * c - b * s;
                    M[q][i] = a * s + b * c;
                    
                    a = V[i][p]; b = V[i][q];
                    V[i][p] = a * c - b * s;
                    V[i][q] = a * s + b * c;
                }
            }
            
            const eigenvalues = [M[0][0], M[1][1], M[2][2]];
            const indices = [0, 1, 2];
            indices.sort((i, j) => eigenvalues[j] - eigenvalues[i]);
            
            const sortedEigenvalues = indices.map(i => eigenvalues[i]);
            const sortedEigenvectors = [[], [], []];
            
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    sortedEigenvectors[j][i] = V[j][indices[i]];
                }
            }
            
            return { values: sortedEigenvalues, vectors: sortedEigenvectors };
        }
        
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // çª—å£å¤§å°è°ƒæ•´
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', init);
    </script>
</body>
</html>
