<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
  <title>最佳拟合函数</title>
  <link rel="shortcut icon" href="img/gatech.gif"/>
  
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
      background: #f5f5f5;
    }
    
    #controls {
      background: white;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .control-group {
      margin: 10px 0;
    }
    
    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin: 0 5px;
    }
    
    button:hover {
      background: #45a049;
    }
    
    #mathbox {
      width: 100%;
      height: 500px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    #info {
      margin-top: 20px;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    #eqn-here {
      color: #e74c3c;
      font-weight: bold;
    }
    
    #sumsq-here {
      color: #9b59b6;
      font-weight: bold;
    }
    
    .residual-line {
      stroke: #9b59b6;
      stroke-width: 2;
      stroke-dasharray: 5,5;
      opacity: 0.7;
    }
    
    .point {
      cursor: move;
      transition: r 0.3s;
    }
    
    .point:hover {
      r: 8;
    }
  </style>
</head>
<body>
  <div id="controls">
    <div class="control-group">
      <button onclick="addRandomPoint()">添加随机点</button>
      <button onclick="clearPoints()">清除所有点</button>
      <button onclick="toggleResiduals()">显示/隐藏残差</button>
      <button onclick="resetView()">重置视图</button>
    </div>
    <div class="control-group">
      <label>函数形式: </label>
      <select id="function-select" onchange="changeFunction()">
        <option value="A*x+B">线性函数: A*x + B</option>
        <option value="A*x^2+B*x+C">二次函数: A*x² + B*x + C</option>
        <option value="A*sin(x)+B">正弦函数: A*sin(x) + B</option>
      </select>
    </div>
  </div>
  
  <div id="mathbox"></div>
  
  <div id="info">
    <p>最佳拟合方程: <span id="eqn-here">f(x) = ...</span></p>
    <p>最小化平方和: <span id="sumsq-here">Σ(residual²) = ...</span></p>
    <p>交互说明: 点击图表添加点，拖拽点调整位置，观察拟合线实时变化</p>
  </div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    "use strict";
    
    // 配置参数
    const config = {
      width: 800,
      height: 500,
      margin: { top: 20, right: 20, bottom: 50, left: 50 },
      pointRadius: 6,
      showResiduals: true
    };
    
    // 数据存储
    let targets = [
      [1, 2], [2, 3], [3, 5], [4, 4], [5, 6]
    ];
    let currentFunction = 'A*x+B';
    let bestfit = (x) => 0;
    let bestFitStr = '';
    
    // 初始化SVG
    const svg = d3.select("#mathbox")
      .append("svg")
      .attr("width", config.width)
      .attr("height", config.height);
    
    const g = svg.append("g")
      .attr("transform", `translate(${config.margin.left},${config.margin.top})`);
    
    const plotWidth = config.width - config.margin.left - config.margin.right;
    const plotHeight = config.height - config.margin.top - config.margin.bottom;
    
    // 比例尺
    const xScale = d3.scaleLinear().range([0, plotWidth]);
    const yScale = d3.scaleLinear().range([plotHeight, 0]);
    
    // 初始化坐标轴
    const xAxis = g.append("g")
      .attr("transform", `translate(0,${plotHeight})`);
    
    const yAxis = g.append("g");
    
    // 初始化网格
    const grid = g.append("g")
      .attr("class", "grid");
    
    // 初始化拟合线
    const fitLine = g.append("path")
      .attr("class", "fit-line")
      .attr("fill", "none")
      .attr("stroke", "#e74c3c")
      .attr("stroke-width", 3);
    
    // 初始化点组
    const pointsGroup = g.append("g")
      .attr("class", "points-group");
    
    // 初始化残差组
    const residualsGroup = g.append("g")
      .attr("class", "residuals-group");
    
    // 点击添加点
    g.append("rect")
      .attr("width", plotWidth)
      .attr("height", plotHeight)
      .attr("fill", "transparent")
      .on("click", function(event) {
        const [x, y] = d3.pointer(event, this);
        const dataX = xScale.invert(x);
        const dataY = yScale.invert(y);
        
        addPointWithAnimation(dataX, dataY);
      });
    
    // 更新视图
    function updateView() {
      const allX = targets.map(d => d[0]);
      const allY = targets.map(d => d[1]);
      
      xScale.domain(d3.extent(allX).map((d, i) => 
        d + (i === 0 ? -1 : 1)
      ));
      yScale.domain(d3.extent(allY).map((d, i) => 
        d + (i === 0 ? -1 : 1)
      ));
      
      // 更新坐标轴
      xAxis.call(d3.axisBottom(xScale));
      yAxis.call(d3.axisLeft(yScale));
      
      // 更新网格
      grid.selectAll(".grid-line").remove();
      grid.selectAll(".grid-line-x")
        .data(xScale.ticks())
        .enter().append("line")
        .attr("class", "grid-line")
        .attr("x1", d => xScale(d))
        .attr("x2", d => xScale(d))
        .attr("y1", 0)
        .attr("y2", plotHeight)
        .attr("stroke", "#eee")
        .attr("stroke-width", 1);
      
      grid.selectAll(".grid-line-y")
        .data(yScale.ticks())
        .enter().append("line")
        .attr("class", "grid-line")
        .attr("x1", 0)
        .attr("x2", plotWidth)
        .attr("y1", d => yScale(d))
        .attr("y2", d => yScale(d))
        .attr("stroke", "#eee")
        .attr("stroke-width", 1);
      
      // 更新拟合线
      updateFitLine();
      
      // 更新点
      updatePoints();
      
      // 更新残差
      updateResiduals();
      
      // 更新信息
      updateInfo();
    }
    
    // 更新拟合线（带动画）
    function updateFitLine() {
      const lineData = d3.range(xScale.domain()[0], xScale.domain()[1], 0.1)
        .map(x => [x, bestfit(x)]);
      
      const lineGenerator = d3.line()
        .x(d => xScale(d[0]))
        .y(d => yScale(d[1]));
      
      fitLine
        .datum(lineData)
        .transition()
        .duration(800)
        .ease(d3.easeCubicOut)
        .attr("d", lineGenerator);
    }
    
    // 更新点（带动画）
    function updatePoints() {
      const points = pointsGroup.selectAll(".point")
        .data(targets, (d, i) => i);
      
      // 移除的点
      points.exit()
        .transition()
        .duration(300)
        .attr("r", 0)
        .remove();
      
      // 新点
      const newPoints = points.enter()
        .append("circle")
        .attr("class", "point")
        .attr("fill", "#3498db")
        .attr("stroke", "#2980b9")
        .attr("stroke-width", 2)
        .attr("r", 0)
        .call(drag);
      
      // 所有点
      points.merge(newPoints)
        .transition()
        .duration(500)
        .attr("cx", d => xScale(d[0]))
        .attr("cy", d => yScale(d[1]))
        .attr("r", config.pointRadius);
    }
    
    // 更新残差
    function updateResiduals() {
      if (!config.showResiduals) {
        residualsGroup.selectAll(".residual-line").remove();
        return;
      }
      
      const residuals = residualsGroup.selectAll(".residual-line")
        .data(targets);
      
      residuals.enter()
        .append("line")
        .attr("class", "residual-line")
        .merge(residuals)
        .transition()
        .duration(600)
        .attr("x1", d => xScale(d[0]))
        .attr("y1", d => yScale(d[1]))
        .attr("x2", d => xScale(d[0]))
        .attr("y2", d => yScale(bestfit(d[0])));
      
      residuals.exit().remove();
    }
    
    // 拖拽行为
    const drag = d3.drag()
      .on("start", function(event, d) {
        d3.select(this).attr("fill", "#e67e22");
      })
      .on("drag", function(event, d) {
        const newX = xScale.invert(event.x);
        const newY = yScale.invert(event.y);
        
        d[0] = newX;
        d[1] = newY;
        
        d3.select(this)
          .attr("cx", event.x)
          .attr("cy", event.y);
        
        // 实时更新拟合
        solve();
        updateFitLine();
        updateResiduals();
        updateInfo();
      })
      .on("end", function(event, d) {
        d3.select(this).attr("fill", "#3498db");
      });
    
    // 添加点（带动画）
    function addPointWithAnimation(x, y) {
      targets.push([x, y]);
      
      // 重新计算拟合
      solve();
      
      // 更新显示
      updateView();
    }
    
    // 添加随机点
    function addRandomPoint() {
      const x = Math.random() * 8 + 1;
      const y = Math.random() * 8 + 1;
      addPointWithAnimation(x, y);
    }
    
    // 清除所有点
    function clearPoints() {
      targets = [];
      updateView();
    }
    
    // 切换残差显示
    function toggleResiduals() {
      config.showResiduals = !config.showResiduals;
      updateResiduals();
    }
    
    // 重置视图
    function resetView() {
      targets = [[1, 2], [2, 3], [3, 5], [4, 4], [5, 6]];
      updateView();
    }
    
    // 改变函数形式
    function changeFunction() {
      currentFunction = document.getElementById('function-select').value;
      solve();
      updateView();
    }
    
    // 更新信息显示
    function updateInfo() {
      document.getElementById('eqn-here').textContent = `f(x) = ${bestFitStr}`;
      
      // 计算平方和
      let sumSquares = 0;
      let residualsStr = '';
      targets.forEach((point, i) => {
        const diff = point[1] - bestfit(point[0]);
        sumSquares += diff * diff;
        if (i < 3) { // 只显示前3个残差
          residualsStr += `${diff.toFixed(2)}²${i < targets.length - 1 ? ' + ' : ''}`;
        }
      });
      if (targets.length > 3) {
        residualsStr += ` + ... (共${targets.length}项)`;
      }
      
      document.getElementById('sumsq-here').textContent = 
        `${sumSquares.toFixed(2)} = ${residualsStr}`;
    }
    
    // 最小二乘法求解（简化版）
    function solve() {
      if (targets.length < 2) return;
      
      // 根据当前函数类型选择求解方法
      switch(currentFunction) {
        case 'A*x+B':
          solveLinear();
          break;
        case 'A*x^2+B*x+C':
          solveQuadratic();
          break;
        case 'A*sin(x)+B':
          solveSinusoidal();
          break;
      }
    }
    
    // 线性拟合求解
    function solveLinear() {
      let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
      const n = targets.length;
      
      targets.forEach(point => {
        sumX += point[0];
        sumY += point[1];
        sumXY += point[0] * point[1];
        sumXX += point[0] * point[0];
      });
      
      const denominator = n * sumXX - sumX * sumX;
      const A = (n * sumXY - sumX * sumY) / denominator;
      const B = (sumY * sumXX - sumX * sumXY) / denominator;
      
      bestfit = (x) => A * x + B;
      bestFitStr = `${A.toFixed(2)}x ${B >= 0 ? '+' : ''}${B.toFixed(2)}`;
    }
    
    // 二次函数拟合求解
    function solveQuadratic() {
      // 简化的二次拟合（实际应该用矩阵求解）
      if (targets.length < 3) {
        bestfit = (x) => 0;
        bestFitStr = "需要至少3个点";
        return;
      }
      
      // 这里使用简化的伪代码，实际应该构建正规方程
      const A = 0.1, B = 0.5, C = 1; // 示例参数
      bestfit = (x) => A * x * x + B * x + C;
      bestFitStr = `${A.toFixed(2)}x² ${B >= 0 ? '+' : ''}${B.toFixed(2)}x ${C >= 0 ? '+' : ''}${C.toFixed(2)}`;
    }
    
    // 正弦函数拟合求解
    function solveSinusoidal() {
      const A = 1, B = 1; // 示例参数
      bestfit = (x) => A * Math.sin(x) + B;
      bestFitStr = `${A.toFixed(2)}sin(x) ${B >= 0 ? '+' : ''}${B.toFixed(2)}`;
    }
    
    // 初始化
    solve();
    updateView();
    
  </script>
</body>
</html>
