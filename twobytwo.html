<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2x2çŸ©é˜µå˜æ¢æ¼”ç¤ºï¼ˆç¾åŒ–ç‰ˆï¼‰</title>
  <style>
    /* å…¨å±€é‡ç½®ä¸åŸºç¡€æ ·å¼ */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
      background: #121212; /* æ›´æ·±çš„èƒŒæ™¯è‰² */
      color: #e0e0e0; /* æµ…è‰²æ–‡å­— */
      padding: 20px;
      min-height: 100vh;
    }
    .container {
      max-width: 1300px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #4a90e2; /* ä¸»é¢˜è“è‰² */
      font-weight: 300;
      letter-spacing: 1px;
    }

    /* ä¸»æ¼”ç¤ºåŒºåŸŸå¸ƒå±€ */
    .main-content {
      display: flex;
      gap: 30px;
    }
    .demo-area {
      flex-grow: 1;
      display: flex;
      gap: 30px;
    }

    /* ç”»å¸ƒå®¹å™¨æ ·å¼ */
    .canvas-container {
      width: 450px; /* å¢å¤§ç”»å¸ƒå°ºå¯¸ */
      height: 450px;
      border: 1px solid #333;
      background: #1e1e1e; /* ç”»å¸ƒèƒŒæ™¯ */
      position: relative;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5); /* é˜´å½±æå‡å±‚æ¬¡æ„Ÿ */
      border-radius: 8px;
      overflow: hidden;
    }
    canvas { width: 100%; height: 100%; }
    .vector-label {
      position: absolute;
      color: #ffffff;
      font-weight: 600;
      background: rgba(0, 0, 0, 0.7);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 14px;
      pointer-events: none;
      z-index: 10;
      transition: all 0.1s ease-out; /* å¢åŠ ç§»åŠ¨å¹³æ»‘åº¦ */
    }

    /* ä¿¡æ¯åŒºåŸŸ */
    .info-area {
      text-align: center;
      margin-top: 10px;
      padding: 10px 0;
      border-top: 1px solid #2e2e2e;
      border-bottom: 1px solid #2e2e2e;
    }
    #matrix-eqn {
      font-size: 22px;
      margin-bottom: 10px;
      color: #bb86fc; /* çªå‡ºçŸ©é˜µæ–¹ç¨‹ */
      font-family: 'Courier New', monospace;
    }
    #det-info {
      color: #03dac6; /* çªå‡ºå¯é€†ä¿¡æ¯ */
      font-size: 16px;
      font-weight: 500;
      margin-bottom: 5px;
    }
    #help-text {
      color: #888888;
      font-size: 14px;
    }

    /* GUIæ§åˆ¶é¢æ¿æ ·å¼ */
    .gui-container {
      width: 350px; /* å®½åº¦è°ƒæ•´ */
      background: #1e1e1e; /* ä¸ç”»å¸ƒç»Ÿä¸€çš„æ·±è‰²èƒŒæ™¯ */
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
      flex-shrink: 0;
    }
    .gui-folder {
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid #333;
    }
    .gui-folder h3 {
      margin-bottom: 10px;
      color: #4a90e2;
      font-size: 18px;
      font-weight: 500;
    }
    .gui-control {
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }
    .gui-control label {
      font-size: 14px;
      color: #cccccc;
      flex-basis: 120px;
    }
    .gui-control input {
      flex: 1;
      padding: 6px;
      border: 1px solid #333;
      background: #2c2c2c;
      color: #e0e0e0;
      border-radius: 4px;
      max-width: 100px;
      text-align: right;
    }
    .gui-control input:focus {
      border-color: #4a90e2;
      outline: none;
    }

    /* æŒ‰é’®æ ·å¼ */
    #reset-btn {
      width: 100%;
      background: #03dac6; /* çªå‡ºæ“ä½œ */
      color: #121212;
      border: none;
      padding: 10px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-bottom: 15px;
      font-weight: bold;
      transition: background 0.2s;
    }
    #reset-btn:hover {
      background: #018786;
    }

    /* å“åº”å¼è°ƒæ•´ */
    @media (max-width: 1200px) {
      .main-content {
        flex-direction: column;
      }
      .demo-area {
        justify-content: center;
        flex-wrap: wrap;
      }
      .gui-container {
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
      }
    }
    @media (max-width: 900px) {
      .demo-area {
        flex-direction: column;
        align-items: center;
      }
      .canvas-container {
        width: 100%;
        max-width: 400px;
        height: 400px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>çº¿æ€§ä»£æ•°ï¼š2x2çŸ©é˜µå˜æ¢äº¤äº’æ¼”ç¤º</h1>

    <div class="main-content">
      <div class="demo-area">
        <div class="canvas-container" id="source-canvas-container">
          <canvas id="source-canvas"></canvas>
          <div class="vector-label" id="source-vector-label">è¾“å…¥å‘é‡ x</div>
        </div>

        <div class="canvas-container" id="target-canvas-container">
          <canvas id="target-canvas"></canvas>
          <div class="vector-label" id="target-vector-label">è¾“å‡ºå‘é‡ b</div>
        </div>
      </div>

      <div class="gui-container">
        <button id="reset-btn">ğŸ”„ é‡ç½®æ‰€æœ‰å˜æ¢</button>
        <div id="transform-folders"></div>
      </div>
    </div>
    
    <div class="info-area">
        <div id="matrix-eqn">[[1,0],[0,1]] Â· [x,y]áµ€ = [x,y]áµ€</div>
        <div id="det-info">çŸ©é˜µè¡Œåˆ—å¼ï¼š1.000ï¼ˆå¯é€†ï¼Œå¯æ‹–æ‹½å³ä¾§å‘é‡ï¼‰</div>
        <div id="help-text">ğŸ’¡ æ‹–æ‹½å‘é‡ç®­å¤´ä¿®æ”¹è¾“å…¥/è¾“å‡º | å·¦ä¾§ï¼šè¾“å…¥å‘é‡ $\mathbf{x}$ (ç»¿è‰²) | å³ä¾§ï¼šè¾“å‡ºå‘é‡ $\mathbf{b} = \mathbf{M} \cdot \mathbf{x}$ (çº¢è‰²)</div>
    </div>
  </div>

  <script>
    // æ ¸å¿ƒé…ç½®
    const CONFIG = {
      canvasSize: 450,    // å¢å¤§ç”»å¸ƒå°ºå¯¸
      gridSize: 10,       // ç½‘æ ¼åˆ†å‰²æ•°
      vectorScale: 40,    // å‘é‡åæ ‡ç¼©æ”¾æ¯”ä¾‹ï¼ˆç”»å¸ƒåƒç´ /å•ä½ï¼‰
      origin: { x: 225, y: 225 }, // ç”»å¸ƒåŸç‚¹ï¼ˆä¸­å¿ƒï¼Œå¯¹åº” 450/2ï¼‰
      numTransforms: 3,   // å˜æ¢æ­¥éª¤æ•°
      initialVector: [1.5, 0.5] // åˆå§‹å‘é‡(x,y)ï¼šä¿®æ”¹åˆå§‹å€¼ä»¥æ›´å¥½åœ°å±•ç¤º
    };

    // å…¨å±€çŠ¶æ€
    let state = {
      matrix: [1, 0, 0, 1], // æœ€ç»ˆå˜æ¢çŸ©é˜µ [a,b,c,d] â†’ M = [[a, b], [c, d]]
      inVec: [...CONFIG.initialVector], 
      outVec: [...CONFIG.initialVector], 
      inverseMatrix: [1, 0, 0, 1], 
      isInvertible: true, 
      transforms: [], 
      dragging: null, 
      dragStart: { x: 0, y: 0 } 
    };

    // åˆå§‹åŒ–å˜æ¢å‚æ•°
    for (let i = 0; i < CONFIG.numTransforms; i++) {
      state.transforms.push({
        xscale: 1.0,
        yscale: 1.0,
        rotate: 0.0, 
        xshear: 0.0, 
        yshear: 0.0, 
        matrix: [1, 0, 0, 1] 
      });
    }

    // ========== ç”»å¸ƒç»˜åˆ¶ ==========
    const sourceCanvas = document.getElementById('source-canvas');
    const targetCanvas = document.getElementById('target-canvas');
    const sourceCtx = sourceCanvas.getContext('2d');
    const targetCtx = targetCanvas.getContext('2d');

    // è®¾ç½®ç”»å¸ƒå®é™…å°ºå¯¸
    sourceCanvas.width = CONFIG.canvasSize;
    sourceCanvas.height = CONFIG.canvasSize;
    targetCanvas.width = CONFIG.canvasSize;
    targetCanvas.height = CONFIG.canvasSize;

    // ç»˜åˆ¶ç½‘æ ¼å’Œåæ ‡è½´
    function drawGrid(ctx) {
      ctx.clearRect(0, 0, CONFIG.canvasSize, CONFIG.canvasSize);
      const gridStep = CONFIG.canvasSize / CONFIG.gridSize;

      // ç»˜åˆ¶ç½‘æ ¼çº¿
      ctx.strokeStyle = '#2e2e2e'; /* æ›´æŸ”å’Œçš„ç½‘æ ¼çº¿ */
      ctx.lineWidth = 1;
      for (let i = 0; i <= CONFIG.gridSize; i++) {
        // æ°´å¹³çº¿
        ctx.beginPath();
        ctx.moveTo(0, i * gridStep);
        ctx.lineTo(CONFIG.canvasSize, i * gridStep);
        ctx.stroke();

        // å‚ç›´çº¿
        ctx.beginPath();
        ctx.moveTo(i * gridStep, 0);
        ctx.lineTo(i * gridStep, CONFIG.canvasSize);
        ctx.stroke();
      }

      // ç»˜åˆ¶åæ ‡è½´
      ctx.strokeStyle = '#4a90e2'; /* ä¸»é¢˜è“ */
      ctx.lineWidth = 2;
      // Xè½´
      ctx.beginPath();
      ctx.moveTo(0, CONFIG.origin.y);
      ctx.lineTo(CONFIG.canvasSize, CONFIG.origin.y);
      ctx.stroke();
      // Yè½´
      ctx.beginPath();
      ctx.moveTo(CONFIG.origin.x, 0);
      ctx.lineTo(CONFIG.origin.x, CONFIG.canvasSize);
      ctx.stroke();

      // åæ ‡è½´ç®­å¤´ï¼ˆç®€åŒ–ï¼‰
      ctx.fillStyle = '#4a90e2';
      // Xè½´ç®­å¤´
      ctx.beginPath();
      ctx.moveTo(CONFIG.canvasSize - 10, CONFIG.origin.y - 5);
      ctx.lineTo(CONFIG.canvasSize, CONFIG.origin.y);
      ctx.lineTo(CONFIG.canvasSize - 10, CONFIG.origin.y + 5);
      ctx.fill();
      // Yè½´ç®­å¤´
      ctx.beginPath();
      ctx.moveTo(CONFIG.origin.x - 5, 10);
      ctx.lineTo(CONFIG.origin.x, 0);
      ctx.lineTo(CONFIG.origin.x + 5, 10);
      ctx.fill();
    }

    // ç»˜åˆ¶å‘é‡
    function drawVector(ctx, vec, color, labelEl) {
      // ç”»å¸ƒåæ ‡è½¬æ¢ï¼šæ•°å­¦åæ ‡(x,y) â†’ ç”»å¸ƒåæ ‡ï¼ˆYè½´åå‘ä¿®æ­£ï¼‰
      const canvasX = CONFIG.origin.x + vec[0] * CONFIG.vectorScale;
      const canvasY = CONFIG.origin.y - vec[1] * CONFIG.vectorScale; 

      // ç»˜åˆ¶å‘é‡çº¿
      ctx.strokeStyle = color;
      ctx.lineWidth = 4; /* ç²—ä¸€ç‚¹çš„çº¿æ¡ */
      ctx.beginPath();
      ctx.moveTo(CONFIG.origin.x, CONFIG.origin.y); 
      ctx.lineTo(canvasX, canvasY);
      ctx.stroke();

      // ç»˜åˆ¶ç®­å¤´
      const angle = Math.atan2(vec[1], vec[0]); 
      const arrowSize = 12;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(canvasX, canvasY);
      ctx.lineTo(
        canvasX - arrowSize * Math.cos(angle - Math.PI / 6),
        canvasY + arrowSize * Math.sin(angle - Math.PI / 6) 
      );
      ctx.lineTo(
        canvasX - arrowSize * Math.cos(angle + Math.PI / 6),
        canvasY + arrowSize * Math.sin(angle + Math.PI / 6)
      );
      ctx.fill();

      // æ›´æ–°æ ‡ç­¾ä½ç½®ï¼ˆæ˜¾ç¤ºåæ ‡ï¼‰
      if (labelEl) {
        labelEl.style.left = `${canvasX + 10 * Math.cos(angle)}px`;
        labelEl.style.top = `${canvasY - 10 * Math.sin(angle)}px`;
        const vecName = labelEl.id.includes('source') ? 'x' : 'b';
        labelEl.innerHTML = `${vecName}: [${vec[0].toFixed(2)}, ${vec[1].toFixed(2)}]áµ€`;
      }

      return { x: canvasX, y: canvasY };
    }

    // åˆ·æ–°ç”»å¸ƒ
    function refreshCanvases() {
      // å·¦ä¾§ï¼šè¾“å…¥å‘é‡ï¼ˆç»¿è‰²ï¼‰
      drawGrid(sourceCtx);
      drawVector(sourceCtx, state.inVec, '#03dac6', document.getElementById('source-vector-label'));

      // å³ä¾§ï¼šè¾“å‡ºå‘é‡ï¼ˆçº¢è‰²ï¼Œä¸å¯é€†æ—¶ç°è‰²ï¼‰
      drawGrid(targetCtx);
      const targetColor = state.isInvertible ? '#e91e63' : '#607d8b'; /* æ›´æœ‰æ´»åŠ›çš„çº¢å’Œç° */
      drawVector(targetCtx, state.outVec, targetColor, document.getElementById('target-vector-label'));
    }

    // ========== æ ¸å¿ƒçŸ©é˜µé€»è¾‘ (ä¿æŒåŸç‰ˆé€»è¾‘ä¸å˜) ==========
    
    function multiplyMatrices(A, B) {
      const a11 = A[0], a12 = A[1];
      const a21 = A[2], a22 = A[3];
      const b11 = B[0], b12 = B[1]; 
      const b21 = B[2], b22 = B[3]; 

      return [
        a11*b11 + a12*b21, a11*b12 + a12*b22,
        a21*b11 + a22*b21, a21*b12 + a22*b22
      ];
    }

    function updateFinalMatrix() {
      let finalMat = [1, 0, 0, 1]; 

      // M = Mâ‚™ Â· ... Â· Mâ‚‚ Â· Mâ‚ ï¼ˆå³åˆ°å·¦ï¼Œä¿è¯å…ˆåº”ç”¨çš„å˜æ¢åœ¨å³ä¾§ï¼‰
      state.transforms.forEach(transform => {
        finalMat = multiplyMatrices(finalMat, transform.matrix);
      });

      state.matrix = finalMat;

      const det = state.matrix[0] * state.matrix[3] - state.matrix[1] * state.matrix[2];
      state.isInvertible = Math.abs(det) > 0.0001; 

      if (state.isInvertible) {
        state.inverseMatrix = [
          state.matrix[3]/det, -state.matrix[1]/det,
          -state.matrix[2]/det, state.matrix[0]/det
        ];
      }

      updateOutVector();
      updateInfoDisplay(det);
    }

    function updateOutVector() {
      const [a, b, c, d] = state.matrix;
      const [x1, x2] = state.inVec;
      state.outVec[0] = a * x1 + b * x2; 
      state.outVec[1] = c * x1 + d * x2; 
    }

    function updateInVector() {
      if (!state.isInvertible) return;
      const [aInv, bInv, cInv, dInv] = state.inverseMatrix;
      const [b1, b2] = state.outVec;
      state.inVec[0] = aInv * b1 + bInv * b2;
      state.inVec[1] = cInv * b1 + dInv * b2;
    }

    function updateTransformMatrix(index) {
      const transform = state.transforms[index];
      const { xscale, yscale, rotate, xshear, yshear } = transform;

      // 1. ç¼©æ”¾
      const scaleMat = [xscale, 0, 0, yscale];

      // 2. æ—‹è½¬
      const cosÎ¸ = Math.cos(rotate);
      const sinÎ¸ = Math.sin(rotate);
      const rotateMat = [cosÎ¸, -sinÎ¸, sinÎ¸, cosÎ¸];

      // 3. Xè½´å‰ªåˆ‡
      const xshearMat = [1, xshear, 0, 1];

      // 4. Yè½´å‰ªåˆ‡
      const yshearMat = [1, 0, yshear, 1];

      // ç»„åˆï¼šç¼©æ”¾ â†’ æ—‹è½¬ â†’ å‰ªåˆ‡ (å·¦ä¹˜æ–°å˜æ¢)
      let mat = multiplyMatrices(scaleMat, rotateMat);
      mat = multiplyMatrices(mat, xshearMat);
      mat = multiplyMatrices(mat, yshearMat);

      transform.matrix = mat;

      updateFinalMatrix();
      refreshCanvases();
    }

    // ========== GUIé¢æ¿å’Œäº¤äº’ ==========
    const transformFoldersEl = document.getElementById('transform-folders');

    function createTransformFolder(index) {
      const transform = state.transforms[index];
      const folderEl = document.createElement('div');
      folderEl.className = 'gui-folder';
      folderEl.innerHTML = `<h3><i class="fas fa-layer-group"></i> å˜æ¢ ${index + 1}</h3>`;

      folderEl.appendChild(createControl('Xè½´ç¼©æ”¾', 'xscale', transform.xscale, -3, 3, 0.05, index));
      folderEl.appendChild(createControl('Yè½´ç¼©æ”¾', 'yscale', transform.yscale, -3, 3, 0.05, index));
      folderEl.appendChild(createControl('æ—‹è½¬(å¼§åº¦)', 'rotate', transform.rotate, -Math.PI, Math.PI, 0.05 * Math.PI, index));
      folderEl.appendChild(createControl('Xè½´å‰ªåˆ‡', 'xshear', transform.xshear, -2, 2, 0.05, index));
      folderEl.appendChild(createControl('Yè½´å‰ªåˆ‡', 'yshear', transform.yshear, -2, 2, 0.05, index));

      transformFoldersEl.appendChild(folderEl);
    }

    function createControl(label, key, initialValue, min, max, step, index) {
      const ctrlEl = document.createElement('div');
      ctrlEl.className = 'gui-control';
      ctrlEl.innerHTML = `
        <label>${label}</label>
        <input type="number" value="${initialValue.toFixed(2)}" 
               min="${min.toFixed(2)}" max="${max.toFixed(2)}" step="${step.toFixed(2)}">
      `;
      const inputEl = ctrlEl.querySelector('input');

      inputEl.addEventListener('input', (e) => {
        // ä½¿ç”¨parseFloat(e.target.value) || 0 æ¥å¤„ç†æ— æ•ˆè¾“å…¥
        const value = parseFloat(e.target.value) || 0; 
        state.transforms[index][key] = value;
        updateTransformMatrix(index);
      });

      return ctrlEl;
    }

    function updateInfoDisplay(det) {
      const eqnEl = document.getElementById('matrix-eqn');
      const detEl = document.getElementById('det-info');

      // ä½¿ç”¨ LaTeX æ ¼å¼åŒ–ï¼Œè™½ç„¶åœ¨è¿™ä¸ªç¯å¢ƒä¸­ä¸ä¼šæ¸²æŸ“ï¼Œä½†æ›´å…·æ•°å­¦è¡¨è¾¾æ„Ÿ
      const [a, b, c, d] = state.matrix.map(v => v.toFixed(3));
      const [x1, x2] = state.inVec.map(v => v.toFixed(3));
      const [b1, b2] = state.outVec.map(v => v.toFixed(3));

      // çŸ©é˜µæ–¹ç¨‹ (ä½¿ç”¨ç®€å•çš„ Unicode ç¬¦å·æ¨¡æ‹Ÿ LaTeX)
      eqnEl.innerHTML = `
        $$\\begin{bmatrix} ${a} & ${b} \\\\ ${c} & ${d} \\end{bmatrix} 
        \\cdot 
        \\begin{bmatrix} ${x1} \\\\ ${x2} \\end{bmatrix} 
        = 
        \\begin{bmatrix} ${b1} \\\\ ${b2} \\end{bmatrix}$$
      `.replace(/\$/g, ''); // ç§»é™¤ $ ç¬¦å·ï¼Œä¿æŒçº¯ HTML æ˜¾ç¤º

      // è¡Œåˆ—å¼ä¿¡æ¯
      const detStr = det.toFixed(4);
      const invertStr = state.isInvertible ? 'ï¼ˆå¯é€†ï¼Œå¯æ‹–æ‹½è¾“å‡ºå‘é‡ï¼‰' : 'ï¼ˆå¥‡å¼‚/ä¸å¯é€†ï¼Œæ— æ³•æ‹–æ‹½è¾“å‡ºå‘é‡ï¼‰';
      detEl.innerHTML = `çŸ©é˜µè¡Œåˆ—å¼ (det $\\mathbf{M}$): ${detStr} ${invertStr}`;
      detEl.style.color = state.isInvertible ? '#03dac6' : '#e91e63';
    }

    function resetAllTransforms() {
      state.transforms.forEach(transform => {
        transform.xscale = 1.0;
        transform.yscale = 1.0;
        transform.rotate = 0.0;
        transform.xshear = 0.0;
        transform.yshear = 0.0;
        transform.matrix = [1, 0, 0, 1]; 
      });

      // é‡ç½®å‘é‡
      state.inVec = [...CONFIG.initialVector];
      state.outVec = [...CONFIG.initialVector];
      updateFinalMatrix();

      // æ›´æ–°GUIæ§ä»¶å€¼
      document.querySelectorAll('.gui-control input').forEach((input) => {
        // ç®€å•åœ°é‡ç½®æ‰€æœ‰è¾“å…¥æ¡†ä¸º 1.00 æˆ– 0.00
        const isScale = input.parentElement.querySelector('label').textContent.includes('ç¼©æ”¾');
        input.value = isScale ? (1.0).toFixed(2) : (0.0).toFixed(2);
      });

      refreshCanvases();
    }

    // æ‹–æ‹½é€»è¾‘ (ä¿æŒåŸç‰ˆé€»è¾‘ä¸å˜)
    function canvasToMath(canvasX, canvasY, rect) {
        // ç”»å¸ƒåæ ‡è½¬æ•°å­¦åæ ‡
        const mathX = (canvasX - CONFIG.origin.x) / CONFIG.vectorScale;
        const mathY = (CONFIG.origin.y - canvasY) / CONFIG.vectorScale;
        return [mathX, mathY];
    }
    
    function bindDragEvents() {
        const sourceContainer = document.getElementById('source-canvas-container');
        const targetContainer = document.getElementById('target-canvas-container');
        
        const handleMouseDown = (e, type) => {
            const canvasEl = type === 'source' ? sourceCanvas : targetCanvas;
            const rect = canvasEl.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const canvasX = clientX - rect.left;
            const canvasY = clientY - rect.top;

            const vec = type === 'source' ? state.inVec : state.outVec;
            const ctx = type === 'source' ? sourceCtx : targetCtx;
            const vecEnd = drawVector(ctx, vec, '#000'); // ä¸´æ—¶ç»˜åˆ¶ä»¥è·å–ä½ç½®

            if (Math.hypot(canvasX - vecEnd.x, canvasY - vecEnd.y) < 25) { // å¢å¤§ç‚¹å‡»åŒºåŸŸ
                state.dragging = type;
                e.preventDefault(); // é˜»æ­¢é»˜è®¤è§¦æ‘¸è¡Œä¸º
            }
        };

        const handleMouseMove = (e) => {
            if (!state.dragging) return;

            const canvasEl = state.dragging === 'source' ? sourceCanvas : targetCanvas;
            const rect = canvasEl.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            const [newMathX, newMathY] = canvasToMath(clientX - rect.left, clientY - rect.top, rect);

            if (state.dragging === 'source') {
                state.inVec[0] = newMathX;
                state.inVec[1] = newMathY;
                updateOutVector(); 
            } else if (state.isInvertible) {
                state.outVec[0] = newMathX;
                state.outVec[1] = newMathY;
                updateInVector(); 
            } else {
                return; // ä¸å¯é€†æ—¶ä¸å¤„ç†è¾“å‡ºå‘é‡æ‹–æ‹½
            }
            
            refreshCanvases();
            const det = state.matrix[0] * state.matrix[3] - state.matrix[1] * state.matrix[2];
            updateInfoDisplay(det);
            e.preventDefault();
        };

        const handleMouseUp = () => {
            state.dragging = null;
        };
        
        // é¼ æ ‡äº‹ä»¶
        sourceContainer.addEventListener('mousedown', (e) => handleMouseDown(e, 'source'));
        targetContainer.addEventListener('mousedown', (e) => handleMouseDown(e, 'target'));
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        
        // è§¦æ‘¸äº‹ä»¶
        sourceContainer.addEventListener('touchstart', (e) => handleMouseDown(e, 'source'));
        targetContainer.addEventListener('touchstart', (e) => handleMouseDown(e, 'target'));
        document.addEventListener('touchmove', handleMouseMove, { passive: false });
        document.addEventListener('touchend', handleMouseUp);
    }

    // ========== åˆå§‹åŒ– ==========
    function init() {
      for (let i = 0; i < CONFIG.numTransforms; i++) {
        createTransformFolder(i);
      }

      document.getElementById('reset-btn').addEventListener('click', resetAllTransforms);

      updateFinalMatrix();
      bindDragEvents();
      refreshCanvases();
    }

    init();
  </script>
</body>
</html>
