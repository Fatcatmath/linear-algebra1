<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1">
    <title>二次型与3D椭球联动 (特征值分解版)</title>
    <!-- 引入依赖库 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathbox@2.3.1/build/mathbox-bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <style>
        body { 
            margin: 0; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; 
            overflow: hidden; 
            background-color: #f0f0f0; 
        }
        /* 说明框样式 */
        .caption {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            max-width: 550px;
            font-size: 14px;
            line-height: 1.6;
            z-index: 10;
        }
        .caption h4 { margin-top: 0; margin-bottom: 15px; color: #333; font-size: 16px; }
        .caption p { margin: 10px 0; color: #555; }
        /* 公式容器样式：确保LaTeX渲染不溢出 */
        .formula-container {
            margin: 15px 0;
            padding: 10px;
            background: rgba(245, 245, 245, 0.8);
            border-radius: 4px;
            overflow-x: auto; /* 防止公式过长溢出 */
        }
        /* 矩阵显示样式：居中对齐 */
        .matrix-container {
            margin: 10px 0;
            text-align: center; /* 矩阵居中 */
        }
        .param-hint { font-size: 0.9em; color: #7f8c8d; margin-top: 10px; }
        .positive-definite { color: #27ae60; font-weight: 600; }
        .non-positive-definite { color: #e74c3c; font-weight: 600; }
        #shape-type { font-weight: 600; color: #34495e; }
        /* 确保katex渲染的公式不被遮挡 */
        .katex { font-size: 1.1em !important; }
        #mathbox-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #555;
        }
    </style>
</head>
<body>
    <div id="mathbox-container"></div>
    <div class="caption">
        <h4>二次型与3D椭球可视化</h4>
        <!-- 完整公式容器：包含二次型方程和矩阵 -->
        <div class="formula-container" id="full-formula"></div>
        <p>矩阵 \( Q \) 状态: <span id="pd-status" class="positive-definite">正定 (椭球)</span></p>
        <p>当前形状: <span id="shape-type">椭球</span></p>
        <p>特征值 (λ₁, λ₂, λ₃): <span id="eigenvalues">计算中...</span></p>
        <p class="param-hint">拖动滑块修改矩阵 Q 的元素，观察椭球的形状、大小和主轴方向变化。</p>
    </div>

    <script type="text/javascript">
        "use strict";

        // 显示加载提示
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'loading';
        loadingDiv.textContent = '正在加载可视化组件...';
        document.body.appendChild(loadingDiv);

        // 1. 初始化 Mathbox
        try {
            var mathbox = mathBox({
                plugins: ['core', 'controls', 'cursor'],
                controls: { klass: THREE.OrbitControls },
                container: document.getElementById('mathbox-container'),
                width: window.innerWidth,
                height: window.innerHeight,
            });
            
            // 移除加载提示
            document.body.removeChild(loadingDiv);
            
            if (mathbox.api) {
                var three = mathbox.three;
                three.renderer.setClearColor(new THREE.Color(0xf0f0f0), 1.0);
                three.camera.position.set(3.5, 3.5, 3.5);

                // 2. 设置视图和坐标系
                var view = mathbox
                    .cartesian({
                        range: [[-4, 4], [-4, 4], [-4, 4]],
                        scale: [1, 1, 1],
                    })
                    .axis({ axis: 1, color: 0x999999, width: 2, ticks: true })
                    .axis({ axis: 2, color: 0x999999, width: 2, ticks: true })
                    .axis({ axis: 3, color: 0x999999, width: 2, ticks: true })
                    .grid({ axes: [1, 2], color: 0xdddddd, width: 1 })
                    .grid({ axes: [1, 3], color: 0xdddddd, width: 1 })
                    .grid({ axes: [2, 3], color: 0xdddddd, width: 1 });

                // 3. 数据与变量初始化
                var quadraticMatrix = [[2.0, 0.5, 0.3], [0.5, 1.0, -0.2], [0.3, -0.2, 0.8]];
                var sphereResolution = 32;
                
                // 创建原始单位球面（透明灰色）
                var initialSpherePoints = createSphereData(sphereResolution);
                view.array({ data: initialSpherePoints, channels: 3 })
                   .mesh({ shaded: true, line: false, color: 0xaaaaaa, opacity: 0.3 });

                // 创建变换后的椭球面（橙色）
                var ellipsoidPoints = transformPoints(initialSpherePoints, quadraticMatrix);
                var ellipsoid = view.array({ data: ellipsoidPoints, channels: 3 })
                                     .mesh({ shaded: true, line: false, color: 0xff7700, opacity: 0.8 });

                // 创建主轴箭头（初始为x,y,z轴）
                var axesData = [
                    0,0,0, 1,0,0, // X轴
                    0,0,0, 0,1,0, // Y轴
                    0,0,0, 0,0,1  // Z轴
                ];
                var eigenAxes = view.array({ data: axesData, channels: 6 })
                                    .line({ color: 0x000000, width: 3 });
                
                // 4. 创建 dat.GUI 控制器
                var guiParams = {
                    Q11: quadraticMatrix[0][0],
                    Q12: quadraticMatrix[0][1],
                    Q13: quadraticMatrix[0][2],
                    Q22: quadraticMatrix[1][1],
                    Q23: quadraticMatrix[1][2],
                    Q33: quadraticMatrix[2][2],
                    reset: function() {
                        this.Q11 = 2.0; this.Q12 = 0.5; this.Q13 = 0.3;
                        this.Q22 = 1.0; this.Q23 = -0.2;
                        this.Q33 = 0.8;
                        updateAll();
                        gui.updateDisplay();
                    }
                };

                var gui = new dat.GUI({ width: 300, autoPlace: false });
                document.body.appendChild(gui.domElement);
                gui.domElement.style.position = 'absolute';
                gui.domElement.style.top = '20px';
                gui.domElement.style.right = '20px';

                gui.add(guiParams, 'Q11', 0.1, 5.0).step(0.1).name('Q₁₁').onChange(updateAll);
                gui.add(guiParams, 'Q12', -1.5, 1.5).step(0.1).name('Q₁₂').onChange(updateAll);
                gui.add(guiParams, 'Q13', -1.5, 1.5).step(0.1).name('Q₁₃').onChange(updateAll);
                gui.add(guiParams, 'Q22', 0.1, 5.0).step(0.1).name('Q₂₂').onChange(updateAll);
                gui.add(guiParams, 'Q23', -1.5, 1.5).step(0.1).name('Q₂₃').onChange(updateAll);
                gui.add(guiParams, 'Q33', 0.1, 5.0).step(0.1).name('Q₃₃').onChange(updateAll);
                gui.add(guiParams, 'reset').name('重置参数');

                // 5. 核心更新函数
                function updateAll() {
                    // 更新矩阵 Q (确保对称)
                    quadraticMatrix[0][0] = guiParams.Q11;
                    quadraticMatrix[0][1] = guiParams.Q12; quadraticMatrix[1][0] = guiParams.Q12;
                    quadraticMatrix[0][2] = guiParams.Q13; quadraticMatrix[2][0] = guiParams.Q13;
                    quadraticMatrix[1][1] = guiParams.Q22;
                    quadraticMatrix[1][2] = guiParams.Q23; quadraticMatrix[2][1] = guiParams.Q23;
                    quadraticMatrix[2][2] = guiParams.Q33;

                    // 更新椭球形状
                    var newEllipsoidPoints = transformPoints(initialSpherePoints, quadraticMatrix);
                    ellipsoid.set('data', newEllipsoidPoints);

                    // 更新状态信息和公式
                    updateStatusAndInfo();
                }
                
                // 变换单位球面得到椭球面（特征值分解法）
                function transformPoints(spherePoints, Q) {
                    var transformedPoints = [];
                    var eigenResult = eigenDecomposition(Q);
                    var eigenvalues = eigenResult.values;
                    var eigenvectors = eigenResult.vectors;
                    var isPD = eigenvalues.every(lambda => lambda > 1e-6);

                    if (isPD) {
                        var P = eigenvectors;
                        var D_inv_sqrt = eigenvalues.map(lambda => 1 / Math.sqrt(lambda));
                        for (var i = 0; i < spherePoints.length; i++) {
                            var p = spherePoints[i];
                            var scaled_p = [p[0] * D_inv_sqrt[0], p[1] * D_inv_sqrt[1], p[2] * D_inv_sqrt[2]];
                            var x = P[0][0] * scaled_p[0] + P[0][1] * scaled_p[1] + P[0][2] * scaled_p[2];
                            var y = P[1][0] * scaled_p[0] + P[1][1] * scaled_p[1] + P[1][2] * scaled_p[2];
                            var z = P[2][0] * scaled_p[0] + P[2][1] * scaled_p[1] + P[2][2] * scaled_p[2];
                            transformedPoints.push(x, y, z);
                        }
                    } else {
                        // 非正定矩阵：简单缩放示意
                        var scale = 2.0 / Math.max(...eigenvalues.map(Math.abs));
                        for (var i = 0; i < spherePoints.length; i++) {
                            var p = spherePoints[i];
                            transformedPoints.push(p[0] * scale, p[1] * scale, p[2] * scale);
                        }
                    }
                    return transformedPoints;
                }
                
                // 更新状态信息和公式渲染
                function updateStatusAndInfo() {
                    var eigenResult = eigenDecomposition(quadraticMatrix);
                    var eigenvalues = eigenResult.values;
                    var eigenvectors = eigenResult.vectors;
                    var isPD = eigenvalues.every(lambda => lambda > 1e-6);

                    // 更新主轴
                    if (isPD) {
                        var axesData = [];
                        for (var i = 0; i < 3; i++) {
                            var v = [eigenvectors[0][i], eigenvectors[1][i], eigenvectors[2][i]];
                            var len = 1 / Math.sqrt(eigenvalues[i]);
                            axesData.push(0, 0, 0, v[0] * len, v[1] * len, v[2] * len);
                        }
                        eigenAxes.set('data', axesData);
                    } else {
                        eigenAxes.set('data', []);
                    }

                    // 更新文本状态
                    document.getElementById('pd-status').className = isPD ? "positive-definite" : "non-positive-definite";
                    document.getElementById('pd-status').textContent = isPD ? "正定 (椭球)" : "非正定 (形状不确定)";
                    document.getElementById('shape-type').textContent = isPD ? "椭球" : "不规则曲面";
                    document.getElementById('eigenvalues').textContent = eigenvalues.map(lambda => lambda.toFixed(2)).join(', ');

                    // 渲染完整公式（二次型方程 + 矩阵）
                    renderFullFormula();
                }

                // 关键修复：渲染完整的二次型公式和矩阵
                function renderFullFormula() {
                    var Q = quadraticMatrix;
                    // 完整LaTeX代码：包含二次型方程和矩阵，用aligned环境对齐
                    var fullTex = `
                        \\begin{aligned}
                        &\\text{二次型方程:} \\quad \\mathbf{x}^T Q \\mathbf{x} = 1 \\\\
                        &\\text{矩阵 } Q: \\quad 
                        Q = \\begin{pmatrix}
                        ${Q[0][0].toFixed(1)} & ${Q[0][1].toFixed(1)} & ${Q[0][2].toFixed(1)} \\\\
                        ${Q[1][0].toFixed(1)} & ${Q[1][1].toFixed(1)} & ${Q[1][2].toFixed(1)} \\\\
                        ${Q[2][0].toFixed(1)} & ${Q[2][1].toFixed(1)} & ${Q[2][2].toFixed(1)}
                        \\end{pmatrix}
                        \\end{aligned}
                    `;
                    // 清空容器后重新渲染（避免累积）
                    var formulaContainer = document.getElementById('full-formula');
                    formulaContainer.innerHTML = '';
                    // 渲染LaTeX，开启displayMode确保公式完整显示
                    katex.render(fullTex, formulaContainer, {
                        displayMode: true,
                        throwOnError: false,
                        errorColor: '#ff0000' // 错误时显示红色，方便调试
                    });
                }

                // 6. 辅助数学函数
                // 创建单位球面数据
                function createSphereData(resolution) {
                    var vertices = [];
                    for (var i = 0; i <= resolution; i++) {
                        var lat = Math.PI * i / resolution;
                        var sinLat = Math.sin(lat);
                        var cosLat = Math.cos(lat);
                        for (var j = 0; j <= resolution; j++) {
                            var lon = 2 * Math.PI * j / resolution;
                            vertices.push([
                                Math.cos(lon) * sinLat,
                                Math.sin(lon) * sinLat,
                                cosLat
                            ]);
                        }
                    }
                    return vertices;
                }
                
                // 特征值分解（Jacobi迭代法，确保对称矩阵）
                function eigenDecomposition(A) {
                    var M = JSON.parse(JSON.stringify(A));
                    // 强制对称（避免输入矩阵不对称导致的问题）
                    for (var i = 0; i < 3; i++) {
                        for (var j = i + 1; j < 3; j++) {
                            M[j][i] = M[i][j] = (M[i][j] + M[j][i]) / 2;
                        }
                    }

                    var V = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
                    var epsilon = 1e-9;
                    var maxIterations = 100;

                    for (var iter = 0; iter < maxIterations; iter++) {
                        // 找到最大非对角元素
                        var maxVal = 0;
                        var p, q;
                        for (var i = 0; i < 3; i++) {
                            for (var j = i + 1; j < 3; j++) {
                                if (Math.abs(M[i][j]) > maxVal) {
                                    maxVal = Math.abs(M[i][j]);
                                    p = i;
                                    q = j;
                                }
                            }
                        }
                        if (maxVal < epsilon) break;

                        // 计算旋转角度
                        var theta = 0.5 * Math.atan2(2 * M[p][q], M[q][q] - M[p][p]);
                        var c = Math.cos(theta);
                        var s = Math.sin(theta);

                        // 旋转矩阵M和特征向量矩阵V
                        for (var i = 0; i < 3; i++) {
                            var a = M[i][p]; var b = M[i][q];
                            M[i][p] = a * c - b * s; M[i][q] = a * s + b * c;
                            a = M[p][i]; b = M[q][i];
                            M[p][i] = a * c - b * s; M[q][i] = a * s + b * c;
                            
                            a = V[i][p]; b = V[i][q];
                            V[i][p] = a * c - b * s; V[i][q] = a * s + b * c;
                        }
                    }

                    // 提取特征值和特征向量（按特征值降序排序）
                    var eigenvalues = [M[0][0], M[1][1], M[2][2]];
                    var indices = [0, 1, 2];
                    indices.sort((i, j) => eigenvalues[j] - eigenvalues[i]);
                    
                    var sortedEigenvalues = indices.map(i => eigenvalues[i]);
                    var sortedEigenvectors = [[], [], []];
                    for (var i = 0; i < 3; i++) {
                        for (var j = 0; j < 3; j++) {
                            sortedEigenvectors[j][i] = V[j][indices[i]];
                        }
                    }

                    return { values: sortedEigenvalues, vectors: sortedEigenvectors };
                }

                // 7. 初始渲染
                updateAll();
                updateStatusAndInfo();

                // 窗口大小调整
                window.addEventListener('resize', function() {
                    mathbox.resize(window.innerWidth, window.innerHeight);
                });

            } else {
                document.body.innerHTML = '<div style="color:red; padding:20px; font-family: sans-serif;">Mathbox 初始化失败。请检查浏览器和网络连接。</div>';
            }
        } catch (error) {
            console.error("初始化错误:", error);
            loadingDiv.textContent = '初始化失败: ' + error.message;
        }
    </script>
</body>
</html>
