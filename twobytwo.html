<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2x2矩阵变换可视化</title>
    <style>
        :root {
            --primary: #3498db;
            --primary-dark: #2980b9;
            --secondary: #2ecc71;
            --secondary-dark: #27ae60;
            --accent: #e74c3c;
            --accent-dark: #c0392b;
            --dark: #2c3e50;
            --darker: #1a252f;
            --light: #ecf0f1;
            --gray: #95a5a6;
            --shadow: rgba(0, 0, 0, 0.2);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, var(--darker) 0%, var(--dark) 100%);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 2px 10px var(--shadow);
        }
        
        .subtitle {
            color: var(--gray);
            font-size: 1.1rem;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .demo-area {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .canvas-container {
            flex: 1;
            min-width: 400px;
            background: var(--dark);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 30px var(--shadow);
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .canvas-header {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .canvas-title {
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .canvas-coords {
            font-size: 0.9rem;
            color: var(--gray);
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 400px;
            background: var(--darker);
        }
        
        .info-panel {
            background: var(--dark);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px var(--shadow);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .matrix-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .matrix {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .matrix-cell {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .matrix-cell.highlight {
            background: rgba(52, 152, 219, 0.2);
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
        }
        
        .vector {
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .vector-cell {
            width: 60px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }
        
        .vector-cell.input {
            background: rgba(46, 204, 113, 0.2);
        }
        
        .vector-cell.output {
            background: rgba(231, 76, 60, 0.2);
        }
        
        .math-symbol {
            font-size: 2rem;
            color: var(--primary);
            display: flex;
            align-items: center;
        }
        
        .properties {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .property {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .property-name {
            color: var(--gray);
        }
        
        .property-value {
            font-weight: 600;
        }
        
        .property-value.invertible {
            color: var(--secondary);
        }
        
        .property-value.not-invertible {
            color: var(--accent);
        }
        
        .control-panel {
            background: var(--dark);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 10px 30px var(--shadow);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .panel-title {
            font-size: 1.3rem;
            font-weight: 600;
        }
        
        .reset-btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .reset-btn:hover {
            background: var(--accent-dark);
            transform: translateY(-2px);
        }
        
        .transform-controls {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 25px;
        }
        
        .transform-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        
        .transform-card:hover {
            border-color: rgba(52, 152, 219, 0.5);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .transform-title {
            font-size: 1.1rem;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .transform-icon {
            width: 24px;
            height: 24px;
            background: var(--primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }
        
        .control-name {
            color: var(--gray);
        }
        
        .control-value {
            font-weight: 600;
            color: var(--primary);
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider {
            flex: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .slider::-webkit-slider-thumb:hover {
            background: var(--primary-dark);
            transform: scale(1.2);
        }
        
        .instructions {
            margin-top: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .instructions h3 {
            margin-bottom: 10px;
            color: var(--primary);
        }
        
        .instructions ul {
            padding-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 8px;
        }
        
        @media (max-width: 768px) {
            .demo-area {
                flex-direction: column;
            }
            
            .canvas-container {
                min-width: 100%;
            }
            
            .matrix-display {
                flex-direction: column;
            }
            
            .transform-controls {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>2×2 矩阵变换可视化</h1>
            <p class="subtitle">通过交互式演示理解线性变换的几何意义。调整矩阵参数，观察向量如何变换，探索缩放、旋转、剪切等基本变换。</p>
        </header>
        
        <div class="demo-area">
            <div class="canvas-container">
                <div class="canvas-header">
                    <div class="canvas-title">输入向量空间</div>
                    <div class="canvas-coords" id="source-coords">x: 2.00, y: 1.00</div>
                </div>
                <canvas id="source-canvas"></canvas>
            </div>
            
            <div class="canvas-container">
                <div class="canvas-header">
                    <div class="canvas-title">输出向量空间</div>
                    <div class="canvas-coords" id="target-coords">x: 2.00, y: 1.00</div>
                </div>
                <canvas id="target-canvas"></canvas>
            </div>
        </div>
        
        <div class="info-panel">
            <div class="matrix-display">
                <div class="matrix" id="matrix-display">
                    <div class="matrix-cell" id="m11">1.00</div>
                    <div class="matrix-cell" id="m12">0.00</div>
                    <div class="matrix-cell" id="m21">0.00</div>
                    <div class="matrix-cell" id="m22">1.00</div>
                </div>
                
                <div class="math-symbol">×</div>
                
                <div class="vector">
                    <div class="vector-cell input" id="v1">2.00</div>
                    <div class="vector-cell input" id="v2">1.00</div>
                </div>
                
                <div class="math-symbol">=</div>
                
                <div class="vector">
                    <div class="vector-cell output" id="b1">2.00</div>
                    <div class="vector-cell output" id="b2">1.00</div>
                </div>
            </div>
            
            <div class="properties">
                <div class="property">
                    <span class="property-name">行列式</span>
                    <span class="property-value" id="det-value">1.000</span>
                </div>
                <div class="property">
                    <span class="property-name">可逆性</span>
                    <span class="property-value invertible" id="invert-value">可逆</span>
                </div>
                <div class="property">
                    <span class="property-name">条件数</span>
                    <span class="property-value" id="cond-value">1.000</span>
                </div>
                <div class="property">
                    <span class="property-name">变换类型</span>
                    <span class="property-value" id="transform-type">恒等变换</span>
                </div>
            </div>
        </div>
        
        <div class="control-panel">
            <div class="panel-header">
                <div class="panel-title">变换控制</div>
                <button class="reset-btn" id="reset-btn">
                    <span>重置所有变换</span>
                </button>
            </div>
            
            <div class="transform-controls" id="transform-folders">
                <!-- 变换控制将通过JavaScript动态生成 -->
            </div>
            
            <div class="instructions">
                <h3>使用说明</h3>
                <ul>
                    <li>拖动左侧向量箭头调整输入向量位置</li>
                    <li>当矩阵可逆时，可拖动右侧向量箭头调整输出向量位置</li>
                    <li>通过下方控制面板调整矩阵变换参数</li>
                    <li>观察矩阵行列式与可逆性的关系</li>
                    <li>尝试创建缩放、旋转、剪切和反射变换</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // 核心配置
        const CONFIG = {
            canvasSize: 400,
            gridSize: 10,
            vectorScale: 30,
            origin: { x: 200, y: 200 },
            numTransforms: 3,
            initialVector: [2, 1]
        };

        // 全局状态
        let state = {
            matrix: [1, 0, 0, 1],
            inVec: [...CONFIG.initialVector],
            outVec: [...CONFIG.initialVector],
            inverseMatrix: [1, 0, 0, 1],
            isInvertible: true,
            transforms: [],
            dragging: null,
            dragStart: { x: 0, y: 0 }
        };

        // 初始化变换参数
        for (let i = 0; i < CONFIG.numTransforms; i++) {
            state.transforms.push({
                xscale: 1.0,
                yscale: 1.0,
                rotate: 0.0,
                xshear: 0.0,
                yshear: 0.0,
                matrix: [1, 0, 0, 1]
            });
        }

        // 获取DOM元素
        const sourceCanvas = document.getElementById('source-canvas');
        const targetCanvas = document.getElementById('target-canvas');
        const sourceCtx = sourceCanvas.getContext('2d');
        const targetCtx = targetCanvas.getContext('2d');

        // 设置画布尺寸
        sourceCanvas.width = CONFIG.canvasSize;
        sourceCanvas.height = CONFIG.canvasSize;
        targetCanvas.width = CONFIG.canvasSize;
        targetCanvas.height = CONFIG.canvasSize;

        // 绘制网格和坐标轴
        function drawGrid(ctx) {
            ctx.clearRect(0, 0, CONFIG.canvasSize, CONFIG.canvasSize);
            const gridStep = CONFIG.canvasSize / CONFIG.gridSize;

            // 绘制网格线
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= CONFIG.gridSize; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * gridStep);
                ctx.lineTo(CONFIG.canvasSize, i * gridStep);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(i * gridStep, 0);
                ctx.lineTo(i * gridStep, CONFIG.canvasSize);
                ctx.stroke();
            }

            // 绘制坐标轴
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            
            // X轴
            ctx.beginPath();
            ctx.moveTo(0, CONFIG.origin.y);
            ctx.lineTo(CONFIG.canvasSize, CONFIG.origin.y);
            ctx.stroke();
            
            // Y轴
            ctx.beginPath();
            ctx.moveTo(CONFIG.origin.x, 0);
            ctx.lineTo(CONFIG.origin.x, CONFIG.canvasSize);
            ctx.stroke();

            // 坐标轴箭头
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            
            // X轴箭头
            ctx.beginPath();
            ctx.moveTo(CONFIG.canvasSize - 10, CONFIG.origin.y - 5);
            ctx.lineTo(CONFIG.canvasSize, CONFIG.origin.y);
            ctx.lineTo(CONFIG.canvasSize - 10, CONFIG.origin.y + 5);
            ctx.fill();
            
            // Y轴箭头
            ctx.beginPath();
            ctx.moveTo(CONFIG.origin.x - 5, 10);
            ctx.lineTo(CONFIG.origin.x, 0);
            ctx.lineTo(CONFIG.origin.x + 5, 10);
            ctx.fill();
        }

        // 绘制向量
        function drawVector(ctx, vec, color, isSource) {
            const canvasX = CONFIG.origin.x + vec[0] * CONFIG.vectorScale;
            const canvasY = CONFIG.origin.y - vec[1] * CONFIG.vectorScale;

            // 绘制向量线
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(CONFIG.origin.x, CONFIG.origin.y);
            ctx.lineTo(canvasX, canvasY);
            ctx.stroke();

            // 绘制向量箭头
            const angle = Math.atan2(vec[1], vec[0]);
            const arrowSize = 10;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(canvasX, canvasY);
            ctx.lineTo(
                canvasX - arrowSize * Math.cos(angle - Math.PI / 6),
                canvasY + arrowSize * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(
                canvasX - arrowSize * Math.cos(angle + Math.PI / 6),
                canvasY + arrowSize * Math.sin(angle + Math.PI / 6)
            );
            ctx.fill();

            // 更新坐标显示
            const coordsEl = isSource ? 
                document.getElementById('source-coords') : 
                document.getElementById('target-coords');
            coordsEl.textContent = `x: ${vec[0].toFixed(2)}, y: ${vec[1].toFixed(2)}`;

            return { x: canvasX, y: canvasY };
        }

        // 刷新画布
        function refreshCanvases() {
            drawGrid(sourceCtx);
            drawVector(sourceCtx, state.inVec, '#2ecc71', true);

            drawGrid(targetCtx);
            const targetColor = state.isInvertible ? '#e74c3c' : '#95a5a6';
            drawVector(targetCtx, state.outVec, targetColor, false);
        }

        // 矩阵乘法
        function multiplyMatrices(A, B) {
            const a11 = A[0], a12 = A[1];
            const a21 = A[2], a22 = A[3];
            const b11 = B[0], b12 = B[1];
            const b21 = B[2], b22 = B[3];

            return [
                a11*b11 + a12*b21, a11*b12 + a12*b22,
                a21*b11 + a22*b21, a21*b12 + a22*b22
            ];
        }

        // 更新最终矩阵
        function updateFinalMatrix() {
            let finalMat = [1, 0, 0, 1];

            state.transforms.forEach(transform => {
                finalMat = multiplyMatrices(finalMat, transform.matrix);
            });

            state.matrix = finalMat;

            const det = state.matrix[0] * state.matrix[3] - state.matrix[1] * state.matrix[2];
            state.isInvertible = Math.abs(det) > 0.0001;

            if (state.isInvertible) {
                state.inverseMatrix = [
                    state.matrix[3]/det, -state.matrix[1]/det,
                    -state.matrix[2]/det, state.matrix[0]/det
                ];
            }

            updateOutVector();
            updateInfoDisplay(det);
        }

        // 更新输出向量
        function updateOutVector() {
            const [a, b, c, d] = state.matrix;
            const [x1, x2] = state.inVec;
            state.outVec[0] = a * x1 + b * x2;
            state.outVec[1] = c * x1 + d * x2;
        }

        // 更新输入向量
        function updateInVector() {
            if (!state.isInvertible) return;
            const [aInv, bInv, cInv, dInv] = state.inverseMatrix;
            const [b1, b2] = state.outVec;
            state.inVec[0] = aInv * b1 + bInv * b2;
            state.inVec[1] = cInv * b1 + dInv * b2;
        }

        // 更新变换矩阵
        function updateTransformMatrix(index) {
            const transform = state.transforms[index];
            const { xscale, yscale, rotate, xshear, yshear } = transform;

            const scaleMat = [xscale, 0, 0, yscale];

            const cosθ = Math.cos(rotate);
            const sinθ = Math.sin(rotate);
            const rotateMat = [cosθ, -sinθ, sinθ, cosθ];

            const xshearMat = [1, xshear, 0, 1];
            const yshearMat = [1, 0, yshear, 1];

            let mat = multiplyMatrices(scaleMat, rotateMat);
            mat = multiplyMatrices(mat, xshearMat);
            mat = multiplyMatrices(mat, yshearMat);

            transform.matrix = mat;

            updateFinalMatrix();
            refreshCanvases();
        }

        // 更新信息显示
        function updateInfoDisplay(det) {
            // 更新矩阵显示
            document.getElementById('m11').textContent = state.matrix[0].toFixed(2);
            document.getElementById('m12').textContent = state.matrix[1].toFixed(2);
            document.getElementById('m21').textContent = state.matrix[2].toFixed(2);
            document.getElementById('m22').textContent = state.matrix[3].toFixed(2);

            // 更新向量显示
            document.getElementById('v1').textContent = state.inVec[0].toFixed(2);
            document.getElementById('v2').textContent = state.inVec[1].toFixed(2);
            document.getElementById('b1').textContent = state.outVec[0].toFixed(2);
            document.getElementById('b2').textContent = state.outVec[1].toFixed(2);

            // 更新属性显示
            document.getElementById('det-value').textContent = det.toFixed(3);
            
            const invertEl = document.getElementById('invert-value');
            if (state.isInvertible) {
                invertEl.textContent = '可逆';
                invertEl.className = 'property-value invertible';
            } else {
                invertEl.textContent = '不可逆';
                invertEl.className = 'property-value not-invertible';
            }

            // 计算条件数（简化版）
            const cond = Math.max(
                Math.abs(state.matrix[0]) + Math.abs(state.matrix[1]),
                Math.abs(state.matrix[2]) + Math.abs(state.matrix[3])
            );
            document.getElementById('cond-value').textContent = cond.toFixed(3);

            // 判断变换类型
            const typeEl = document.getElementById('transform-type');
            if (det === 1 && state.matrix[0] === 1 && state.matrix[3] === 1 && 
                state.matrix[1] === 0 && state.matrix[2] === 0) {
                typeEl.textContent = '恒等变换';
            } else if (det < 0) {
                typeEl.textContent = '反射变换';
            } else if (Math.abs(rotate) > 0.01) {
                typeEl.textContent = '旋转变换';
            } else if (Math.abs(xshear) > 0.01 || Math.abs(yshear) > 0.01) {
                typeEl.textContent = '剪切变换';
            } else if (Math.abs(xscale - 1) > 0.01 || Math.abs(yscale - 1) > 0.01) {
                typeEl.textContent = '缩放变换';
            } else {
                typeEl.textContent = '一般线性变换';
            }
        }

        // 创建变换控制
        function createTransformFolder(index) {
            const transform = state.transforms[index];
            const folderEl = document.createElement('div');
            folderEl.className = 'transform-card';
            
            folderEl.innerHTML = `
                <div class="transform-title">
                    <div class="transform-icon">${index + 1}</div>
                    <span>变换 ${index + 1}</span>
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span class="control-name">X轴缩放</span>
                        <span class="control-value" id="xscale-value-${index}">${transform.xscale.toFixed(2)}</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" class="slider" id="xscale-${index}" 
                               min="-3" max="3" step="0.05" value="${transform.xscale}">
                    </div>
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span class="control-name">Y轴缩放</span>
                        <span class="control-value" id="yscale-value-${index}">${transform.yscale.toFixed(2)}</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" class="slider" id="yscale-${index}" 
                               min="-3" max="3" step="0.05" value="${transform.yscale}">
                    </div>
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span class="control-name">旋转(弧度)</span>
                        <span class="control-value" id="rotate-value-${index}">${transform.rotate.toFixed(2)}</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" class="slider" id="rotate-${index}" 
                               min="${-Math.PI}" max="${Math.PI}" step="0.05" value="${transform.rotate}">
                    </div>
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span class="control-name">X轴剪切</span>
                        <span class="control-value" id="xshear-value-${index}">${transform.xshear.toFixed(2)}</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" class="slider" id="xshear-${index}" 
                               min="-2" max="2" step="0.05" value="${transform.xshear}">
                    </div>
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span class="control-name">Y轴剪切</span>
                        <span class="control-value" id="yshear-value-${index}">${transform.yshear.toFixed(2)}</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" class="slider" id="yshear-${index}" 
                               min="-2" max="2" step="0.05" value="${transform.yshear}">
                    </div>
                </div>
            `;

            // 绑定事件
            ['xscale', 'yscale', 'rotate', 'xshear', 'yshear'].forEach(key => {
                const slider = folderEl.querySelector(`#${key}-${index}`);
                const valueEl = folderEl.querySelector(`#${key}-value-${index}`);
                
                slider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    state.transforms[index][key] = value;
                    valueEl.textContent = value.toFixed(2);
                    updateTransformMatrix(index);
                });
            });

            document.getElementById('transform-folders').appendChild(folderEl);
        }

        // 重置所有变换
        function resetAllTransforms() {
            state.transforms.forEach(transform => {
                transform.xscale = 1.0;
                transform.yscale = 1.0;
                transform.rotate = 0.0;
                transform.xshear = 0.0;
                transform.yshear = 0.0;
                transform.matrix = [1, 0, 0, 1];
            });

            state.inVec = [...CONFIG.initialVector];
            state.outVec = [...CONFIG.initialVector];
            updateFinalMatrix();

            // 更新所有滑块和显示值
            for (let i = 0; i < CONFIG.numTransforms; i++) {
                const transform = state.transforms[i];
                document.getElementById(`xscale-${i}`).value = transform.xscale;
                document.getElementById(`yscale-${i}`).value = transform.yscale;
                document.getElementById(`rotate-${i}`).value = transform.rotate;
                document.getElementById(`xshear-${i}`).value = transform.xshear;
                document.getElementById(`yshear-${i}`).value = transform.yshear;
                
                document.getElementById(`xscale-value-${i}`).textContent = transform.xscale.toFixed(2);
                document.getElementById(`yscale-value-${i}`).textContent = transform.yscale.toFixed(2);
                document.getElementById(`rotate-value-${i}`).textContent = transform.rotate.toFixed(2);
                document.getElementById(`xshear-value-${i}`).textContent = transform.xshear.toFixed(2);
                document.getElementById(`yshear-value-${i}`).textContent = transform.yshear.toFixed(2);
            }

            refreshCanvases();
        }

        // 绑定拖拽事件
        function bindDragEvents() {
            const sourceContainer = document.getElementById('source-canvas-container');
            const targetContainer = document.getElementById('target-canvas-container');

            sourceContainer.addEventListener('mousedown', (e) => {
                const rect = sourceCanvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;

                const vecEnd = drawVector(sourceCtx, state.inVec, '#2ecc71', true);
                if (Math.hypot(canvasX - vecEnd.x, canvasY - vecEnd.y) < 20) {
                    state.dragging = 'source';
                    state.dragStart.x = canvasX;
                    state.dragStart.y = canvasY;
                }
            });

            targetContainer.addEventListener('mousedown', (e) => {
                if (!state.isInvertible) return;

                const rect = targetCanvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;

                const vecEnd = drawVector(targetCtx, state.outVec, '#e74c3c', false);
                if (Math.hypot(canvasX - vecEnd.x, canvasY - vecEnd.y) < 20) {
                    state.dragging = 'target';
                    state.dragStart.x = canvasX;
                    state.dragStart.y = canvasY;
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (!state.dragging) return;

                const rect = state.dragging === 'source' 
                    ? sourceCanvas.getBoundingClientRect() 
                    : targetCanvas.getBoundingClientRect();
                
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;

                const deltaCanvasX = canvasX - state.dragStart.x;
                const deltaCanvasY = state.dragStart.y - canvasY;
                const deltaX = deltaCanvasX / CONFIG.vectorScale;
                const deltaY = deltaCanvasY / CONFIG.vectorScale;

                if (state.dragging === 'source') {
                    state.inVec[0] += deltaX;
                    state.inVec[1] += deltaY;
                    updateOutVector();
                } else {
                    state.outVec[0] += deltaX;
                    state.outVec[1] += deltaY;
                    updateInVector();
                }

                state.dragStart.x = canvasX;
                state.dragStart.y = canvasY;

                refreshCanvases();
                const det = state.matrix[0] * state.matrix[3] - state.matrix[1] * state.matrix[2];
                updateInfoDisplay(det);
            });

            document.addEventListener('mouseup', () => {
                state.dragging = null;
            });
        }

        // 初始化
        function init() {
            for (let i = 0; i < CONFIG.numTransforms; i++) {
                createTransformFolder(i);
            }

            document.getElementById('reset-btn').addEventListener('click', resetAllTransforms);

            updateFinalMatrix();
            bindDragEvents();
            refreshCanvases();
        }

        // 启动应用
        init();
    </script>
</body>
</html>
