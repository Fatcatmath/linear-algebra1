<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2x2矩阵变换演示（独立可运行版）</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: Arial, sans-serif; background: #1a1a1a; color: white; padding: 20px; }
    .container { max-width: 1200px; margin: 0 auto; }
    h1 { text-align: center; margin-bottom: 20px; color: #3498db; }
    .demo-area { display: flex; gap: 40px; justify-content: center; margin: 30px 0; }
    .canvas-container { width: 400px; height: 400px; border: 2px solid #3498db; background: #2c3e50; position: relative; }
    canvas { width: 100%; height: 100%; }
    .vector-label { position: absolute; color: white; font-weight: bold; background: rgba(0,0,0,0.7); padding: 2px 6px; border-radius: 3px; pointer-events: none; }
    .info-area { text-align: center; margin: 20px 0; }
    #matrix-eqn { font-size: 20px; margin-bottom: 10px; color: #ecf0f1; }
    #det-info { color: #2ecc71; font-size: 16px; margin-bottom: 10px; }
    #help-text { color: #95a5a6; font-size: 14px; }
    .gui-container { position: fixed; top: 20px; right: 20px; background: #34495e; padding: 15px; border-radius: 8px; max-width: 250px; }
    .gui-folder { margin-bottom: 15px; border-bottom: 1px solid #4a6584; padding-bottom: 10px; }
    .gui-folder h3 { margin-bottom: 8px; color: #3498db; font-size: 16px; }
    .gui-control { margin-bottom: 6px; display: flex; align-items: center; gap: 8px; }
    .gui-control label { font-size: 14px; flex: 1; }
    .gui-control input { flex: 2; padding: 4px; border: none; border-radius: 3px; }
    button { background: #3498db; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-top: 10px; }
    button:hover { background: #2980b9; }
  </style>
</head>
<body>
  <div class="container">
    <h1>2x2矩阵变换交互式演示</h1>

    <div class="demo-area">
      <!-- 左侧原始视图 -->
      <div class="canvas-container" id="source-canvas-container">
        <canvas id="source-canvas"></canvas>
        <div class="vector-label" id="source-vector-label">输入向量 x</div>
      </div>

      <!-- 右侧变换后视图 -->
      <div class="canvas-container" id="target-canvas-container">
        <canvas id="target-canvas"></canvas>
        <div class="vector-label" id="target-vector-label">输出向量 b</div>
      </div>
    </div>

    <div class="info-area">
      <div id="matrix-eqn">[[1,0],[0,1]] · [x,y] = [x,y]</div>
      <div id="det-info">矩阵行列式：1.000（可逆）</div>
      <div id="help-text">拖拽向量箭头调整位置 | 右侧面板调整矩阵变换参数</div>
    </div>

    <!-- 右侧GUI面板 -->
    <div class="gui-container">
      <button id="reset-btn">重置所有变换</button>
      <div id="transform-folders"></div>
    </div>
  </div>

  <script>
    // 核心配置
    const CONFIG = {
      canvasSize: 400,    // 画布大小
      gridSize: 10,       // 网格分割数
      vectorScale: 30,    // 向量坐标缩放比例（画布像素/单位）
      origin: { x: 200, y: 200 }, // 画布原点（中心）
      numTransforms: 3,   // 变换步骤数
      initialVector: [2, 3] // 初始向量(x,y)
    };

    // 全局状态
    let state = {
      matrix: [1, 0, 0, 1], // 最终变换矩阵 [a,b,c,d] → [[a,b],[c,d]]
      inVec: [...CONFIG.initialVector], // 输入向量
      outVec: [...CONFIG.initialVector], // 输出向量
      inverseMatrix: [1, 0, 0, 1], // 逆矩阵
      isInvertible: true, // 是否可逆
      transforms: [], // 变换参数列表
      dragging: null, // 拖拽状态：'source'/'target'/null
      dragStart: { x: 0, y: 0 } // 拖拽起始位置
    };

    // 初始化变换参数
    for (let i = 0; i < CONFIG.numTransforms; i++) {
      state.transforms.push({
        type: 'none', // 变换类型：none/scale/rotate/xshear/yshear
        xscale: 1.0,
        yscale: 1.0,
        rotate: 0.0, // 弧度
        xshear: 0.0,
        yshear: 0.0,
        matrix: [1, 0, 0, 1] // 该变换的矩阵
      });
    }

    // ========== 画布绘制 ==========
    const sourceCanvas = document.getElementById('source-canvas');
    const targetCanvas = document.getElementById('target-canvas');
    const sourceCtx = sourceCanvas.getContext('2d');
    const targetCtx = targetCanvas.getContext('2d');

    // 设置画布实际尺寸（避免模糊）
    sourceCanvas.width = CONFIG.canvasSize;
    sourceCanvas.height = CONFIG.canvasSize;
    targetCanvas.width = CONFIG.canvasSize;
    targetCanvas.height = CONFIG.canvasSize;

    // 绘制网格
    function drawGrid(ctx) {
      ctx.clearRect(0, 0, CONFIG.canvasSize, CONFIG.canvasSize);
      const gridStep = CONFIG.canvasSize / CONFIG.gridSize;

      // 绘制网格线
      ctx.strokeStyle = '#4a6584';
      ctx.lineWidth = 1;
      for (let i = 0; i <= CONFIG.gridSize; i++) {
        // 水平线
        ctx.beginPath();
        ctx.moveTo(0, i * gridStep);
        ctx.lineTo(CONFIG.canvasSize, i * gridStep);
        ctx.stroke();

        // 垂直线
        ctx.beginPath();
        ctx.moveTo(i * gridStep, 0);
        ctx.lineTo(i * gridStep, CONFIG.canvasSize);
        ctx.stroke();
      }

      // 绘制坐标轴
      ctx.strokeStyle = '#3498db';
      ctx.lineWidth = 2;
      // X轴
      ctx.beginPath();
      ctx.moveTo(0, CONFIG.origin.y);
      ctx.lineTo(CONFIG.canvasSize, CONFIG.origin.y);
      ctx.stroke();
      // Y轴
      ctx.beginPath();
      ctx.moveTo(CONFIG.origin.x, 0);
      ctx.lineTo(CONFIG.origin.x, CONFIG.canvasSize);
      ctx.stroke();

      // 坐标轴箭头
      ctx.fillStyle = '#3498db';
      // X轴箭头
      ctx.beginPath();
      ctx.moveTo(CONFIG.canvasSize - 10, CONFIG.origin.y - 5);
      ctx.lineTo(CONFIG.canvasSize, CONFIG.origin.y);
      ctx.lineTo(CONFIG.canvasSize - 10, CONFIG.origin.y + 5);
      ctx.fill();
      // Y轴箭头
      ctx.beginPath();
      ctx.moveTo(CONFIG.origin.x - 5, 10);
      ctx.lineTo(CONFIG.origin.x, 0);
      ctx.lineTo(CONFIG.origin.x + 5, 10);
      ctx.fill();
    }

    // 绘制向量（从原点出发）
    function drawVector(ctx, vec, color, labelEl) {
      const x = CONFIG.origin.x + vec[0] * CONFIG.vectorScale;
      const y = CONFIG.origin.y - vec[1] * CONFIG.vectorScale; // 画布y轴向下，数学y轴向上

      // 绘制向量线
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(CONFIG.origin.x, CONFIG.origin.y);
      ctx.lineTo(x, y);
      ctx.stroke();

      // 绘制箭头
      const angle = Math.atan2(y - CONFIG.origin.y, x - CONFIG.origin.x);
      const arrowSize = 10;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(
        x - arrowSize * Math.cos(angle - Math.PI / 6),
        y - arrowSize * Math.sin(angle - Math.PI / 6)
      );
      ctx.lineTo(
        x - arrowSize * Math.cos(angle + Math.PI / 6),
        y - arrowSize * Math.sin(angle + Math.PI / 6)
      );
      ctx.fill();

      // 更新标签位置
      if (labelEl) {
        labelEl.style.left = `${x + 10}px`;
        labelEl.style.top = `${y - 20}px`;
      }

      return { x, y }; // 返回向量终点画布坐标
    }

    // 刷新画布
    function refreshCanvases() {
      // 绘制左侧原始视图
      drawGrid(sourceCtx);
      drawVector(sourceCtx, state.inVec, '#2ecc71', document.getElementById('source-vector-label'));

      // 绘制右侧变换后视图
      drawGrid(targetCtx);
      const targetColor = state.isInvertible ? '#e74c3c' : '#95a5a6';
      drawVector(targetCtx, state.outVec, targetColor, document.getElementById('target-vector-label'));
    }

    // ========== 矩阵计算 ==========
    // 矩阵乘法：a * b（均为[1,0,0,1]格式的2x2矩阵）
    function multiplyMatrices(a, b) {
      const a11 = a[0], a12 = a[1], a21 = a[2], a22 = a[3];
      const b11 = b[0], b12 = b[1], b21 = b[2], b22 = b[3];
      return [
        a11*b11 + a12*b21, // 新a
        a11*b12 + a12*b22, // 新b
        a21*b11 + a22*b21, // 新c
        a21*b12 + a22*b22  // 新d
      ];
    }

    // 计算最终变换矩阵（所有变换叠加）
    function updateFinalMatrix() {
      let finalMat = [1, 0, 0, 1]; // 单位矩阵
      state.transforms.forEach(transform => {
        finalMat = multiplyMatrices(finalMat, transform.matrix);
      });
      state.matrix = finalMat;

      // 计算行列式和逆矩阵
      const det = state.matrix[0] * state.matrix[3] - state.matrix[1] * state.matrix[2];
      state.isInvertible = Math.abs(det) > 0.0001;
      if (state.isInvertible) {
        state.inverseMatrix = [
          state.matrix[3]/det, -state.matrix[1]/det,
          -state.matrix[2]/det, state.matrix[0]/det
        ];
      }

      // 更新输出向量
      updateOutVector();

      // 更新信息显示
      updateInfoDisplay(det);
    }

    // 计算输出向量（inVec → 矩阵变换 → outVec）
    function updateOutVector() {
      const [a, b, c, d] = state.matrix;
      state.outVec[0] = a * state.inVec[0] + b * state.inVec[1];
      state.outVec[1] = c * state.inVec[0] + d * state.inVec[1];
    }

    // 计算输入向量（outVec → 逆矩阵 → inVec）
    function updateInVector() {
      if (!state.isInvertible) return;
      const [a, b, c, d] = state.inverseMatrix;
      state.inVec[0] = a * state.outVec[0] + b * state.outVec[1];
      state.inVec[1] = c * state.outVec[0] + d * state.outVec[1];
    }

    // 更新页面信息（矩阵公式、行列式）
    function updateInfoDisplay(det) {
      const eqnEl = document.getElementById('matrix-eqn');
      const detEl = document.getElementById('det-info');

      // 格式化矩阵和向量显示
      const mat = state.matrix.map(v => v.toFixed(2));
      const inVec = state.inVec.map(v => v.toFixed(2));
      const outVec = state.outVec.map(v => v.toFixed(2));
      eqnEl.innerHTML = `[[${mat[0]},${mat[1]}],[${mat[2]},${mat[3]}]] · [${inVec[0]},${inVec[1]}] = [${outVec[0]},${outVec[1]}]`;

      // 行列式信息
      const detStr = det.toFixed(3);
      const invertStr = state.isInvertible ? '（可逆）' : '（不可逆，无法拖拽右侧向量）';
      detEl.innerHTML = `矩阵行列式：${detStr} ${invertStr}`;
      detEl.style.color = state.isInvertible ? '#2ecc71' : '#e74c3c';
    }

    // ========== GUI面板生成 ==========
    const transformFoldersEl = document.getElementById('transform-folders');

    // 生成单个变换的GUI控件
    function createTransformFolder(index) {
      const transform = state.transforms[index];
      const folderEl = document.createElement('div');
      folderEl.className = 'gui-folder';
      folderEl.innerHTML = `<h3>变换 ${index + 1}</h3>`;

      // 缩放控件
      const scaleGroup = createControlGroup('缩放', [
        { label: 'X轴', key: 'xscale', min: -3, max: 3, step: 0.05, onChange: () => updateTransformMatrix(index, 'scale') },
        { label: 'Y轴', key: 'yscale', min: -3, max: 3, step: 0.05, onChange: () => updateTransformMatrix(index, 'scale') }
      ]);

      // 旋转控件
      const rotateGroup = createControlGroup('旋转（弧度）', [
        { label: '角度', key: 'rotate', min: -Math.PI, max: Math.PI, step: 0.05, onChange: () => updateTransformMatrix(index, 'rotate') }
      ]);

      // 剪切控件
      const shearGroup = createControlGroup('剪切', [
        { label: 'X轴', key: 'xshear', min: -3, max: 3, step: 0.05, onChange: () => updateTransformMatrix(index, 'xshear') },
        { label: 'Y轴', key: 'yshear', min: -3, max: 3, step: 0.05, onChange: () => updateTransformMatrix(index, 'yshear') }
      ]);

      folderEl.appendChild(scaleGroup);
      folderEl.appendChild(rotateGroup);
      folderEl.appendChild(shearGroup);
      transformFoldersEl.appendChild(folderEl);

      // 初始化控件值
      updateControlValues(folderEl, transform);
    }

    // 创建控件组
    function createControlGroup(title, controls) {
      const groupEl = document.createElement('div');
      groupEl.innerHTML = `<strong>${title}</strong>`;
      controls.forEach(ctrl => {
        const ctrlEl = document.createElement('div');
        ctrlEl.className = 'gui-control';
        ctrlEl.innerHTML = `
          <label>${ctrl.label}</label>
          <input type="number" data-key="${ctrl.key}" min="${ctrl.min}" max="${ctrl.max}" step="${ctrl.step}" value="0">
        `;
        const inputEl = ctrlEl.querySelector('input');
        inputEl.addEventListener('input', (e) => {
          state.transforms[ctrl.index][ctrl.key] = parseFloat(e.target.value) || 0;
          ctrl.onChange();
        });
        groupEl.appendChild(ctrlEl);
      });
      return groupEl;
    }

    // 更新控件值
    function updateControlValues(folderEl, transform) {
      folderEl.querySelectorAll('input').forEach(input => {
        const key = input.dataset.key;
        input.value = transform[key].toFixed(2);
      });
    }

    // 更新单个变换的矩阵
    function updateTransformMatrix(index, type) {
      const transform = state.transforms[index];
      transform.type = type;

      switch (type) {
        case 'scale':
          transform.matrix = [transform.xscale, 0, 0, transform.yscale];
          break;
        case 'rotate':
          const c = Math.cos(transform.rotate);
          const s = Math.sin(transform.rotate);
          transform.matrix = [c, -s, s, c];
          break;
        case 'xshear':
          transform.matrix = [1, transform.xshear, 0, 1];
          break;
        case 'yshear':
          transform.matrix = [1, 0, transform.yshear, 1];
          break;
      }

      // 重新计算最终矩阵和界面
      updateFinalMatrix();
      refreshCanvases();
    }

    // 重置所有变换
    function resetAllTransforms() {
      state.transforms.forEach(transform => {
        transform.type = 'none';
        transform.xscale = 1.0;
        transform.yscale = 1.0;
        transform.rotate = 0.0;
        transform.xshear = 0.0;
        transform.yshear = 0.0;
        transform.matrix = [1, 0, 0, 1];
      });

      // 重置向量和矩阵
      state.inVec = [...CONFIG.initialVector];
      state.outVec = [...CONFIG.initialVector];
      updateFinalMatrix();

      // 更新控件值
      document.querySelectorAll('.gui-folder').forEach((folder, index) => {
        updateControlValues(folder, state.transforms[index]);
      });

      refreshCanvases();
    }

    // ========== 拖拽逻辑 ==========
    // 绑定拖拽事件
    function bindDragEvents() {
      // 左侧输入向量拖拽
      const sourceContainer = document.getElementById('source-canvas-container');
      sourceContainer.addEventListener('mousedown', (e) => {
        const rect = sourceCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        // 检查是否点击了向量箭头（简化：点击终点附近20px内）
        const vecEnd = drawVector(sourceCtx, state.inVec, '#2ecc71');
        if (Math.hypot(x - vecEnd.x, y - vecEnd.y) < 20) {
          state.dragging = 'source';
          state.dragStart.x = x;
          state.dragStart.y = y;
        }
      });

      // 右侧输出向量拖拽（仅可逆时）
      const targetContainer = document.getElementById('target-canvas-container');
      targetContainer.addEventListener('mousedown', (e) => {
        if (!state.isInvertible) return;
        const rect = targetCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const vecEnd = drawVector(targetCtx, state.outVec, '#e74c3c');
        if (Math.hypot(x - vecEnd.x, y - vecEnd.y) < 20) {
          state.dragging = 'target';
          state.dragStart.x = x;
          state.dragStart.y = y;
        }
      });

      // 全局鼠标移动和松开
      document.addEventListener('mousemove', (e) => {
        if (!state.dragging) return;

        const rect = state.dragging === 'source' ? sourceCanvas.getBoundingClientRect() : targetCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // 计算坐标变化（画布像素 → 数学坐标）
        const deltaX = (x - state.dragStart.x) / CONFIG.vectorScale;
        const deltaY = (state.dragStart.y - y) / CONFIG.vectorScale; // 画布y轴向下，数学y轴向上

        if (state.dragging === 'source') {
          state.inVec[0] += deltaX;
          state.inVec[1] += deltaY;
          updateOutVector();
        } else {
          state.outVec[0] += deltaX;
          state.outVec[1] += deltaY;
          updateInVector();
        }

        // 更新拖拽起始位置
        state.dragStart.x = x;
        state.dragStart.y = y;

        // 刷新界面
        refreshCanvases();
        updateInfoDisplay(state.matrix[0] * state.matrix[3] - state.matrix[1] * state.matrix[2]);
      });

      document.addEventListener('mouseup', () => {
        state.dragging = null;
      });

      // 触摸事件支持（移动端）
      ['touchstart', 'touchmove', 'touchend'].forEach(eventType => {
        document.addEventListener(eventType, (e) => {
          const touch = e.touches ? e.touches[0] : null;
          if (!touch) return;

          // 模拟鼠标事件
          const mouseEvent = new MouseEvent(
            eventType === 'touchstart' ? 'mousedown' :
            eventType === 'touchmove' ? 'mousemove' : 'mouseup',
            { clientX: touch.clientX, clientY: touch.clientY }
          );
          document.dispatchEvent(mouseEvent);
          e.preventDefault();
        });
      });
    }

    // ========== 初始化 ==========
    function init() {
      // 生成GUI面板
      for (let i = 0; i < CONFIG.numTransforms; i++) {
        createTransformFolder(i);
      }

      // 绑定重置按钮事件
      document.getElementById('reset-btn').addEventListener('click', resetAllTransforms);

      // 初始化矩阵和向量
      updateFinalMatrix();

      // 绑定拖拽事件
      bindDragEvents();

      // 首次绘制
      refreshCanvases();
    }

    // 启动应用
    init();
  </script>
</body>
</html>
