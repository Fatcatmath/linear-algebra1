<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äºŒæ¬¡å‹ä¸3Dæ¤­çƒå¯è§†åŒ–</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            max-width: 400px;
            backdrop-filter: blur(10px);
        }
        .info-panel h2 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 1.4em;
        }
        .formula-container {
            background: rgba(245, 245, 245, 0.8);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #3498db;
        }
        .status-item {
            margin: 8px 0;
            padding: 8px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 6px;
            font-size: 0.95em;
        }
        .positive { color: #27ae60; font-weight: 600; }
        .negative { color: #e74c3c; font-weight: 600; }
        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            text-align: center;
        }
        .axis-legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9em;
        }
        .axis-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .axis-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="info-panel">
        <h2>ğŸ¯ äºŒæ¬¡å‹ä¸3Dæ¤­çƒå¯è§†åŒ–</h2>
        
        <div class="formula-container" id="formula">
            æ­£åœ¨åŠ è½½å…¬å¼...
        </div>
        
        <div class="status-item">
            <strong>çŸ©é˜µçŠ¶æ€:</strong> <span id="matrix-status" class="positive">æ­£å®š (æ¤­çƒ)</span>
        </div>
        
        <div class="status-item">
            <strong>ç‰¹å¾å€¼:</strong> <span id="eigenvalues">è®¡ç®—ä¸­...</span>
        </div>
        
        <div class="status-item">
            <strong>ä¸»è½´é•¿åº¦:</strong> <span id="axis-lengths">è®¡ç®—ä¸­...</span>
        </div>
        
        <div class="status-item">
            <strong>å½“å‰å½¢çŠ¶:</strong> <span id="shape-type">æ¤­çƒ</span>
        </div>
        
        <div style="margin-top: 15px; font-size: 0.9em; color: #7f8c8d;">
            ğŸ’¡ è°ƒæ•´å³ä¾§å‚æ•°è§‚å¯Ÿæ¤­çƒå½¢çŠ¶å’Œä¸»è½´å˜åŒ–
        </div>
    </div>

    <div class="control-panel" id="control-panel">
        <!-- GUIæ§ä»¶å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
    </div>

    <div class="axis-legend">
        <div class="axis-item">
            <div class="axis-color" style="background: #ff4444;"></div>
            <span>ä¸»è½´ 1 (æœ€é•¿è½´)</span>
        </div>
        <div class="axis-item">
            <div class="axis-color" style="background: #44ff44;"></div>
            <span>ä¸»è½´ 2 (ä¸­é—´è½´)</span>
        </div>
        <div class="axis-item">
            <div class="axis-color" style="background: #4444ff;"></div>
            <span>ä¸»è½´ 3 (æœ€çŸ­è½´)</span>
        </div>
    </div>

    <script>
        // åˆå§‹åŒ–Three.jsåœºæ™¯
        let scene, camera, renderer, ellipsoid, axesHelper;
        let principalAxes = []; // å­˜å‚¨ä¸»è½´ç®­å¤´
        let quadraticMatrix = [[2.0, 0.5, 0.3], [0.5, 1.0, -0.2], [0.3, -0.2, 0.8]];
        
        // ä¸»è½´é¢œè‰²
        const axisColors = [0xff4444, 0x44ff44, 0x4444ff];
        const axisLabels = ['ä¸»è½´ 1 (æœ€é•¿)', 'ä¸»è½´ 2 (ä¸­é—´)', 'ä¸»è½´ 3 (æœ€çŸ­)'];
        
        // åˆå§‹åŒ–å‡½æ•°
        function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // æ·»åŠ å…‰æº
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            // åˆ›å»ºåæ ‡è½´
            const axesHelper = new THREE.AxesHelper(4);
            scene.add(axesHelper);
            
            // åˆ›å»ºç½‘æ ¼
            const gridHelper = new THREE.GridHelper(8, 8, 0x888888, 0x888888);
            gridHelper.rotation.x = Math.PI / 2;
            scene.add(gridHelper);
            
            // åˆ›å»ºåˆå§‹æ¤­çƒ
            createEllipsoid();
            
            // åˆ›å»ºä¸»è½´
            createPrincipalAxes();
            
            // åˆå§‹åŒ–æ§åˆ¶å™¨
            initControls();
            
            // åˆå§‹æ¸²æŸ“
            updateInfo();
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();
            
            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize);
            
            // æ·»åŠ é¼ æ ‡æ§åˆ¶
            initMouseControls();
        }
        
        // åˆå§‹åŒ–é¼ æ ‡æ§åˆ¶
        function initMouseControls() {
            let isMouseDown = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!isMouseDown) return;
                
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                if (ellipsoid) {
                    ellipsoid.rotation.y += deltaX * 0.01;
                    ellipsoid.rotation.x += deltaY * 0.01;
                    
                    // ä¸»è½´ä¹Ÿè·Ÿéšæ—‹è½¬
                    principalAxes.forEach(axis => {
                        axis.rotation.y += deltaX * 0.01;
                        axis.rotation.x += deltaY * 0.01;
                    });
                }
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                camera.position.multiplyScalar(1 + e.deltaY * 0.001);
            });
        }
        
        // åˆ›å»ºæ¤­çƒ
        function createEllipsoid() {
            if (ellipsoid) {
                scene.remove(ellipsoid);
            }
            
            const geometry = new THREE.SphereGeometry(1, 32, 32);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0xff7700,
                transparent: true,
                opacity: 0.8,
                shininess: 100
            });
            
            ellipsoid = new THREE.Mesh(geometry, material);
            
            // åº”ç”¨å˜æ¢çŸ©é˜µ
            applyMatrixTransformation();
            
            scene.add(ellipsoid);
        }
        
        // åˆ›å»ºä¸»è½´ç®­å¤´
        function createPrincipalAxes() {
            // æ¸…é™¤ç°æœ‰ä¸»è½´
            principalAxes.forEach(axis => scene.remove(axis));
            principalAxes = [];
            
            const eigenResult = eigenDecomposition(quadraticMatrix);
            const eigenvalues = eigenResult.values;
            const eigenvectors = eigenResult.vectors;
            const isPD = eigenvalues.every(lambda => lambda > 1e-6);
            
            if (!isPD) return;
            
            for (let i = 0; i < 3; i++) {
                const axisLength = 1 / Math.sqrt(eigenvalues[i]);
                const direction = new THREE.Vector3(
                    eigenvectors[0][i],
                    eigenvectors[1][i],
                    eigenvectors[2][i]
                ).normalize();
                
                // åˆ›å»ºç®­å¤´
                const arrowHelper = new THREE.ArrowHelper(
                    direction,
                    new THREE.Vector3(0, 0, 0),
                    axisLength,
                    axisColors[i],
                    0.1, // ç®­å¤´å¤´éƒ¨é•¿åº¦
                    0.05 // ç®­å¤´å¤´éƒ¨å®½åº¦
                );
                
                principalAxes.push(arrowHelper);
                scene.add(arrowHelper);
            }
        }
        
        // æ›´æ–°ä¸»è½´
        function updatePrincipalAxes() {
            // æ¸…é™¤ç°æœ‰ä¸»è½´
            principalAxes.forEach(axis => scene.remove(axis));
            principalAxes = [];
            
            const eigenResult = eigenDecomposition(quadraticMatrix);
            const eigenvalues = eigenResult.values;
            const eigenvectors = eigenResult.vectors;
            const isPD = eigenvalues.every(lambda => lambda > 1e-6);
            
            if (!isPD) return;
            
            for (let i = 0; i < 3; i++) {
                const axisLength = 1 / Math.sqrt(eigenvalues[i]);
                const direction = new THREE.Vector3(
                    eigenvectors[0][i],
                    eigenvectors[1][i],
                    eigenvectors[2][i]
                ).normalize();
                
                // åˆ›å»ºç®­å¤´
                const arrowHelper = new THREE.ArrowHelper(
                    direction,
                    new THREE.Vector3(0, 0, 0),
                    axisLength,
                    axisColors[i],
                    0.1,
                    0.05
                );
                
                principalAxes.push(arrowHelper);
                scene.add(arrowHelper);
            }
        }
        
        // åº”ç”¨çŸ©é˜µå˜æ¢
        function applyMatrixTransformation() {
            const eigenResult = eigenDecomposition(quadraticMatrix);
            const eigenvalues = eigenResult.values;
            const eigenvectors = eigenResult.vectors;
            const isPD = eigenvalues.every(lambda => lambda > 1e-6);
            
            if (isPD) {
                // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
                const scaleX = 1 / Math.sqrt(eigenvalues[0]);
                const scaleY = 1 / Math.sqrt(eigenvalues[1]);
                const scaleZ = 1 / Math.sqrt(eigenvalues[2]);
                
                // è®¾ç½®ç¼©æ”¾
                ellipsoid.scale.set(scaleX, scaleY, scaleZ);
                
                // åˆ›å»ºæ—‹è½¬çŸ©é˜µ
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.set(
                    eigenvectors[0][0], eigenvectors[1][0], eigenvectors[2][0], 0,
                    eigenvectors[0][1], eigenvectors[1][1], eigenvectors[2][1], 0,
                    eigenvectors[0][2], eigenvectors[1][2], eigenvectors[2][2], 0,
                    0, 0, 0, 1
                );
                
                // åº”ç”¨æ—‹è½¬
                ellipsoid.rotation.setFromRotationMatrix(rotationMatrix);
            } else {
                // éæ­£å®šæƒ…å†µï¼šç®€å•ç¼©æ”¾
                const maxEigen = Math.max(...eigenvalues.map(Math.abs));
                const scale = 2.0 / maxEigen;
                ellipsoid.scale.set(scale, scale, scale);
                ellipsoid.rotation.set(0, 0, 0);
            }
        }
        
        // åˆå§‹åŒ–æ§åˆ¶å™¨
        function initControls() {
            const guiParams = {
                Q11: quadraticMatrix[0][0],
                Q12: quadraticMatrix[0][1],
                Q13: quadraticMatrix[0][2],
                Q22: quadraticMatrix[1][1],
                Q23: quadraticMatrix[1][2],
                Q33: quadraticMatrix[2][2],
                showAxes: true,
                reset: function() {
                    this.Q11 = 2.0; this.Q12 = 0.5; this.Q13 = 0.3;
                    this.Q22 = 1.0; this.Q23 = -0.2;
                    this.Q33 = 0.8;
                    updateMatrix();
                    gui.updateDisplay();
                }
            };
            
            const gui = new dat.GUI({ 
                autoPlace: false,
                width: 300
            });
            
            document.getElementById('control-panel').appendChild(gui.domElement);
            
            const matrixFolder = gui.addFolder('çŸ©é˜µå‚æ•° Q');
            matrixFolder.add(guiParams, 'Q11', 0.1, 5.0).step(0.1).name('Qâ‚â‚').onChange(updateMatrix);
            matrixFolder.add(guiParams, 'Q12', -1.5, 1.5).step(0.1).name('Qâ‚â‚‚').onChange(updateMatrix);
            matrixFolder.add(guiParams, 'Q13', -1.5, 1.5).step(0.1).name('Qâ‚â‚ƒ').onChange(updateMatrix);
            matrixFolder.add(guiParams, 'Q22', 0.1, 5.0).step(0.1).name('Qâ‚‚â‚‚').onChange(updateMatrix);
            matrixFolder.add(guiParams, 'Q23', -1.5, 1.5).step(0.1).name('Qâ‚‚â‚ƒ').onChange(updateMatrix);
            matrixFolder.add(guiParams, 'Q33', 0.1, 5.0).step(0.1).name('Qâ‚ƒâ‚ƒ').onChange(updateMatrix);
            matrixFolder.open();
            
            const viewFolder = gui.addFolder('è§†å›¾æ§åˆ¶');
            viewFolder.add(guiParams, 'showAxes').name('æ˜¾ç¤ºä¸»è½´').onChange(function(value) {
                principalAxes.forEach(axis => {
                    axis.visible = value;
                });
            });
            viewFolder.add(guiParams, 'reset').name('é‡ç½®å‚æ•°');
            viewFolder.open();
            
            function updateMatrix() {
                quadraticMatrix[0][0] = guiParams.Q11;
                quadraticMatrix[0][1] = guiParams.Q12; quadraticMatrix[1][0] = guiParams.Q12;
                quadraticMatrix[0][2] = guiParams.Q13; quadraticMatrix[2][0] = guiParams.Q13;
                quadraticMatrix[1][1] = guiParams.Q22;
                quadraticMatrix[1][2] = guiParams.Q23; quadraticMatrix[2][1] = guiParams.Q23;
                quadraticMatrix[2][2] = guiParams.Q33;
                
                applyMatrixTransformation();
                updatePrincipalAxes();
                updateInfo();
            }
        }
        
        // æ›´æ–°ä¿¡æ¯æ˜¾ç¤º
        function updateInfo() {
            const eigenResult = eigenDecomposition(quadraticMatrix);
            const eigenvalues = eigenResult.values;
            const isPD = eigenvalues.every(lambda => lambda > 1e-6);
            
            // è®¡ç®—ä¸»è½´é•¿åº¦
            const axisLengths = isPD ? eigenvalues.map(lambda => (1 / Math.sqrt(lambda)).toFixed(3)) : ['-', '-', '-'];
            
            // æ›´æ–°çŠ¶æ€
            document.getElementById('matrix-status').className = isPD ? 'positive' : 'negative';
            document.getElementById('matrix-status').textContent = 
                isPD ? 'æ­£å®š (æ¤­çƒ)' : 'éæ­£å®š (åŒæ›²é¢)';
            document.getElementById('eigenvalues').textContent = 
                eigenvalues.map(lambda => lambda.toFixed(3)).join(', ');
            document.getElementById('axis-lengths').textContent = 
                axisLengths.join(', ');
            document.getElementById('shape-type').textContent = 
                isPD ? 'æ¤­çƒ' : 'åŒæ›²é¢';
            
            // æ›´æ–°å…¬å¼
            renderFormula();
        }
        
        // æ¸²æŸ“å…¬å¼
        function renderFormula() {
            const Q = quadraticMatrix;
            const formulaTex = `
                \\begin{aligned}
                &\\text{äºŒæ¬¡å‹: } \\mathbf{x}^T Q \\mathbf{x} = 1 \\\\
                &Q = \\begin{pmatrix}
                ${Q[0][0].toFixed(2)} & ${Q[0][1].toFixed(2)} & ${Q[0][2].toFixed(2)} \\\\
                ${Q[1][0].toFixed(2)} & ${Q[1][1].toFixed(2)} & ${Q[1][2].toFixed(2)} \\\\
                ${Q[2][0].toFixed(2)} & ${Q[2][1].toFixed(2)} & ${Q[2][2].toFixed(2)}
                \\end{pmatrix}
                \\end{aligned}
            `;
            
            katex.render(formulaTex, document.getElementById('formula'), {
                displayMode: true,
                throwOnError: false
            });
        }
        
        // ç‰¹å¾å€¼åˆ†è§£å‡½æ•°
        function eigenDecomposition(A) {
            let M = JSON.parse(JSON.stringify(A));
            
            // ç¡®ä¿å¯¹ç§°
            for (let i = 0; i < 3; i++) {
                for (let j = i + 1; j < 3; j++) {
                    M[j][i] = M[i][j] = (M[i][j] + M[j][i]) / 2;
                }
            }
            
            let V = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
            const epsilon = 1e-9;
            const maxIterations = 100;
            
            for (let iter = 0; iter < maxIterations; iter++) {
                let maxVal = 0;
                let p, q;
                
                for (let i = 0; i < 3; i++) {
                    for (let j = i + 1; j < 3; j++) {
                        if (Math.abs(M[i][j]) > maxVal) {
                            maxVal = Math.abs(M[i][j]);
                            p = i;
                            q = j;
                        }
                    }
                }
                
                if (maxVal < epsilon) break;
                
                const theta = 0.5 * Math.atan2(2 * M[p][q], M[q][q] - M[p][p]);
                const c = Math.cos(theta);
                const s = Math.sin(theta);
                
                for (let i = 0; i < 3; i++) {
                    let a = M[i][p], b = M[i][q];
                    M[i][p] = a * c - b * s;
                    M[i][q] = a * s + b * c;
                    
                    a = M[p][i]; b = M[q][i];
                    M[p][i] = a * c - b * s;
                    M[q][i] = a * s + b * c;
                    
                    a = V[i][p]; b = V[i][q];
                    V[i][p] = a * c - b * s;
                    V[i][q] = a * s + b * c;
                }
            }
            
            const eigenvalues = [M[0][0], M[1][1], M[2][2]];
            const indices = [0, 1, 2];
            indices.sort((i, j) => eigenvalues[j] - eigenvalues[i]);
            
            const sortedEigenvalues = indices.map(i => eigenvalues[i]);
            const sortedEigenvectors = [[], [], []];
            
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    sortedEigenvectors[j][i] = V[j][indices[i]];
                }
            }
            
            return { values: sortedEigenvalues, vectors: sortedEigenvectors };
        }
        
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // çª—å£å¤§å°è°ƒæ•´
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', init);
    </script>
</body>
</html>
